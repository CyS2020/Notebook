### 数据库
1. Mysql存储引擎
- MyIsam  非聚集索引索引MYI和数据MYD分别存放  非事务安全型  支持表锁 
- InnoDB  数据和索引在一个文件中ibd   事务安全型   支持行锁也支持表锁

2. 那些索引
- B+树索引 Hash索引 全文索引
- 密集索引: 数据库中的每个搜索键值都有一个索引记录。索引记录包含搜索键值和指向磁盘上实际记录的指针。
- 稀疏索引: 不会为每个搜索关键字创建索引记录。我们首先按索引记录进行操作，然后到达数据的实际位置。
           如果我们要寻找的数据不是我们通过遵循索引直接到达的位置，那么系统将开始顺序搜索，直到找到所需的数据为止。
- 聚集索引: 通过每张表的主键顺序进行存放，其叶子节点存放的是这张表的每行完整数据。也正是我们有时称呼的主键索引(对比一下稠密索引)
- 非聚集索引: (辅助索引，二级索引)其叶子节点并不包含行记录的全部数据，其叶子结点的数据包含辅助索引(key)和主键索引(value)

3. InnoDB
- 若主键被定义则主键即为密集索引，叶子节点存放的是这张表的每行完整数据
- 若未定义主键，则该表的第一个唯一索引则作为密集索引
- 若不满足上述条件，InnoDB内部会生成一个隐藏主键
- 非主键索引(稀疏索引)，叶子节点存储相关键位和对应的主键值，包含两次查找
 
4. 如何定位并优化慢查询
- 根据慢日志查询慢日志sql
- 使用explain等分析工具，type(index、all全表扫描)，extra(Using filesort、Using temporary)
- 修改sql或者尽量让sql走索引 

5. 联合索引的最左前缀匹配原则
- mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配
- =和in可以乱序，mysql查询优化器会帮你优化成可以识别的形式

6. 索引不是越多越好
- 数据量小的表不需要建立索引，建立会增加额外的索引开销
- 数据变更需要维护索引，因此更多的索引意味着更多的维护成本
- 更多的索引意味着也需要更多的空间

7. InnoDB锁两阶段锁
- 事务里面，分为加锁(lock)阶段和解锁(unlock)阶段,也即所有的lock操作都在unlock操作之前
- 在事务中只有提交(commit)或者回滚(rollback)时才是解锁阶段，其余时间为加锁阶段。
- 当不走索引的时候整张表都会被锁住，此时查询使用的是表级锁，


|MyIsam|InnoDb|
|:---:|:---:|
|频繁执行全表count||
|对数据增删改的频率不高，查询非常高|数据增删改查都相当频繁|
|没有事务|可靠性比较高，支持事务|

8. 锁分类
- 按照粒度划分：表级锁，行级锁，页级锁(BDB)
- 按锁级别划分：共享锁，排它锁
- 按加锁方式分：自动锁，显示锁
- 按照操作划分：DML锁，DDL锁
- 按使用方式分：乐观锁，悲观锁

9. 数据库事务的四大特性ACID
- 原子性(Atomic): 事务包含所有操作的要么完全执行要么全部失败回滚
- 一致性(Consistency): 事务应该确保数据库状态从一个一致状态，转变为另外一个一致的状态，数据库中的数据应满足完整性约束
- 隔离性(Isolation): 多个事务并发执行，一个事务的执行不应该影响其他事务的执行
- 持久性(Durability): 一个事务一旦提交，对数据库的修改应该永久保存在数据库中，确保已提交的事务不能因数据库故障丢失

10. 事务隔离级别
- 更新丢失--mysql所有事务隔离级别在数据库层面均可避免
- 脏读--READ-COMMITTED事务隔离级别以上可避免，允许事务读取其他事务未提交的更新数据
- 不可重复读--REPEATABLE-READ事务隔离级别以上可避免，一个事务两次读取事务中间另一个事务进行修改，造成两次读取数据不一致
- 幻读--SERIALIZABLE事务隔离级别以上可避免，一个事务以插入删除方式修改另一个事务的结果集，导致该事务像出现幻觉一样

|事务隔离级别|更新丢失|脏读|不可重复读|幻读|
|:---:|:---:|:---:|:---:|:---:|
|未提交读|避免|发生|发生|发生|
|已提交读|避免|避免|发生|发生|
|可重复读|避免|避免|避免|发生|
|串行化|避免|避免|避免|避免|

11. InnoDB RR隔离级别下如何避免幻读
- 表象: 快照读(非阻塞读) --在快照读读情况下，mysql通过mvcc来避免幻读。
- 内在: next-key锁(行锁+gap锁) --在当前读读情况下，mysql通过next-key来避免幻读。

11. RR下gap锁出现的场景
1. 走主键索引或唯一索引的当前读中
- 如果where条件全部命中不会用Gap锁，只会加记录锁
- 如果where条件部分命中或者全不命中，则会加gap锁
2. 走非唯一索引或者不走索引的当前读中会使用gap锁
- 非唯一索引中左开右闭区间
- 不走索引时会对所有的gap上锁，等于锁表
- 疑问解答: 事务隔离机制下RR是不避免幻读的(接口层)，但是InnoDB实现中RR是可以避免幻读的(实现层)

12. 快照读(非阻塞读)和当前读(阻塞读)
- 当前读: select...lock in share mode, select...for update
- 当前读: update, delete, insert, 加了锁的增删改查语句
- 当前读：MVCC中修改数据的操作（增删改）需要进行加锁操作，从而读取最新的数据；
- 快照读: 不加锁的非阻塞读(前提是隔离级别不为SERIALIZABLE), select
- 快照读: 快照读的地方很关键，创建快照的时机决定了读取数据的版本
- 快照读：MVCC中的SELECT操作是读取快照中的数据，不需要进行加锁；

13. RC、RR级别下如何实现非阻塞读
- 数据行里的DB_TRX_ID(最后一次修改事务id)、DB_ROLL_PTR(回滚指针)、DB_ROW_ID(随新行递增的id)字段
- undo日志: 存储老版数据，有insert undo log, update undo log，串行化的结果
- read view: 可见性判断算法--查看undo log中某个版本，能看见DB_TRX_ID比自己小的那个版本
- READ-COMMITTED: 可以读到别的事务新的数据，事务中每次调用快照读的时候都回创建一个新的快照，所以每次读取的都是最新的事务
- REPEATABLE-READ: 不可以读到别的事务新的数据，事务在第一条快照读会创建一个快照read view，记录当前系统其它活跃事务，此后再读还是同一个read view

14. 语法部分 
 - GROUP BY: SELECT子句中的列名必须为分组列或列函数(只适用于同一张表); 列函数对于group by子句定义的每个组各返回一个结果
 - HAVING: 通常与GROUP BY子句一起使用; WHERE过滤行HAVING过滤组; 同一SQL顺序: WHERE > GROUP BY > HAVING
 
15. MySQL分页查询
- limit(每页显示的条数)两个参数去分页查询数据库表中的数据，那我们知道MySql数据库提供了分页的函数limit m,n
- 客户端通过传递pageNo(页码)，pageSize(每页显示的条数)两个参数去分页查询数据库表中的数据;
- 对应的MySQL命令如：select * from 表 limit (pageNo-1) * pageSize, pageSize; 
 
16. 回表查询
- 通过普通索引定位到主键值，在通过聚集索引定位到行记录，这就是所谓的回表查询
- explain的输出结果Extra字段为Using index时，能够触发索引覆盖。
- 索引覆盖：只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。
- 如何实现索引覆盖：常见的方法是：将被查询的字段，建立到联合索引里去。
- extra为null或者using index condition就是二级索引回表
- 这篇文章讲的很清楚 https://my.oschina.net/u/4312790/blog/4122058

15. 分库分表
- 将原本存储于单个数据库上的数据拆分到多个数据库，把原来存储于单张数据表的数据拆封到多张数据表中
- 分库分表可以分为两种形式：垂直切分和水平切分
- 水平分库：每个库结构一样，数据不一样，没有交集，库多了可以缓解io压力和cpu压力
- 水平分表：每个表结构一样，数据不一样，没有交集，表变小提高sql执行效率，缓解cpu压力
- 垂直分库：每个库结构、数据都不一样，所有库并集为全量数据
- 垂直分表：每个表结构、数据都不一样，至少有一列交集用于关联数据，所有表的并集为全量数据
参考这篇文章：https://www.zhihu.com/question/448775613