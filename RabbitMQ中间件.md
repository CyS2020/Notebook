### RabbitMQ
#### 1. 消息中间件的应用场景
- 异步处理: 异步任务更快的返回, 剩下任务交给中间件等待消费
- 应用解耦: 不直接依赖接口, 模块可以平滑升级无需重新适配 
- 流量控制: 大并发的场景下全部进来并存入消息队列中, 进行流量削峰

#### 2. 消息中间件概念
- 消息代理: 发消息给消息代理, 取消息从消息代理取, 理解为安装了消息中间件的服务器
- 目的地: 消息代理保证消息传递到指定的目的地, 消息队列主要有两种形式的目的地
    - 队列: 点对点消息通信--消息只有唯一的发送者和接受者(指队列), 但并不是说只能有一个接收者, 谁从队列拿到谁消费
    - 主题: 发布(publish)/订阅(subscribe)消息通信--消息发送到主题, 监听该主题的接收者都能收到这个消息, 都能消费
- JMS(JAVA消息服务): 基于JVM消息代理规范, ActiveMQ、HornetMQ是JMS实现
- AMQP(高级消息队列协议): 也是一个消息代理的规范, 兼容JMS, RabbitMQ是AMQP的实现

#### 3. RabbitMQ概念
- Message: 消息是不具名的, 它由消息头和消息体组成. 消息体是不透明的, 而消息头则由一系列的可选属性组成. 这些属性包括routing-key(路由键)、priority(相对于其他消息的优先权)、delivery-mode(指出该消息可能需要持久性存储)等
- Publisher: 消息的生产者, 也是一个向交换器发布消息的客户端应用程序
- Exchange: 交换器, 用来接收生产者发送的消息并将这些消息路由给服务器中的队列. Exchange有4种类型：direct(默认), fanout, topic, 和headers, 不同类型的Exchange转发消息的策略有所区别
- Queue: 消息队列, 用来保存消息直到发送给消费者. 它是消息的容器也是消息的终点. 一个消息可投入一个或多个队列. 消息一直在队列里面等待消费者连接到这个队列将其取走
- Binding: 绑定, 用于消息队列和交换器之间的关联. 一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则, 所以可以将交换器理解成一个由绑定构成的路由表. Exchange和Queue的绑定可以是多对多的关系
- Connection: 网络连接, 比如一个TCP连接
- Channel: 信道, 多路复用连接中的一条独立的双向数据流通道. 信道是建立在真实的TCP连接内的虚拟连接, AMQP命令都是通过信道发出去的, 不管是发布消息、订阅队列还是接收消息, 这些动作都是通过信道完成. 因为对于操作系统来说建立和销毁TCP都是非常昂贵的开销所以引入了信道的概念以复用一条TCP连接
- Consumer: 消息的消费者, 表示一个从消息队列中取得消息的客户端应用程序
- Virtual Host: 虚拟主机,表示一批交换器、消息队列和相关对象. 虚拟主机是共享相同的身份认证和加密环境的独立服务器域. 每个vhost本质上就是一个mini版的RabbitMQ服务器, 拥有自己的队列、交换器、绑定和权限机制. vhost是AMQP概念的基础, 必须在连接时指定, RabbitMQ 默认的vhost是/
- Broker: 表示消息队列服务器实体
![概念原理](https://github.com/CyS2020/SpringCloud-Mall/blob/main/resources/RabbitMQ%E5%8E%9F%E7%90%86.PNG?raw=true)

#### 4. Exchange类型
- direct: 单播模式, 消息中的路由键(routing key)如果和Binding中的binding key一致, 交换器就将消息发到对应的队列中, 路由键与队列名完全匹配
- fanout: 广播模式, fanout交换器不处理路由键, 只是简单的将队列绑定到交换器上, 每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上
- topic: 自定义模式, topic交换器通过模式匹配分配消息的路由键属性, 将路由键和某个模式进行匹配, 此时队列需要绑定到一个模式上. 单词之间用点隔开, 它同样也会识别两个通配符: # *

#### 5. 消息确认
- 可靠抵达-ConfirmCallback
    - 消息只要被broker接收到就会执行confirmCallback, 如果是cluster模式, 需要所有broker接收到才会调用confirmCallback
    - 被broker接收到只能表示message已经到达服务器, 并不能保证消息一定会被投递到目标queue里, 所以需要用到接下来的returnCallback
- 可靠抵达-ReturnCallback
    - 如果未能投递到目标queue里将调用returnCallback, 可以记录下详细到投递数据, 定期的巡检或者自动纠错都需要这些数据