### RabbitMQ
#### 1. 消息中间件的应用场景
- 异步处理: 异步任务更快的返回, 剩下任务交给中间件等待消费
- 应用解耦: 不直接依赖接口, 模块可以平滑升级无需重新适配 
- 流量控制: 大并发的场景下全部进来并存入消息队列中, 进行流量削峰

#### 2. 消息中间件概念
- 消息代理: 发消息给消息代理, 取消息从消息代理取, 理解为安装了消息中间件的服务器
- 目的地: 消息代理保证消息传递到指定的目的地, 消息队列主要有两种形式的目的地
    - 队列: 点对点消息通信--消息只有唯一的发送者和接受者(指队列), 但并不是说只能有一个接收者, 谁从队列拿到谁消费
    - 主题: 发布(publish)/订阅(subscribe)消息通信--消息发送到主题, 监听该主题的接收者都能收到这个消息, 都能消费
- JMS(JAVA消息服务): 基于JVM消息代理规范, ActiveMQ、HornetMQ是JMS实现
- AMQP(高级消息队列协议): 也是一个消息代理的规范, 兼容JMS, RabbitMQ是AMQP的实现

#### 3. RabbitMQ概念
- Message: 消息是不具名的, 它由消息头和消息体组成. 消息体是不透明的, 而消息头则由一系列的可选属性组成. 这些属性包括routing-key(路由键)、priority(相对于其他消息的优先权)、delivery-mode(指出该消息可能需要持久性存储)等
- Publisher: 消息的生产者, 也是一个向交换器发布消息的客户端应用程序
- Exchange: 交换器, 用来接收生产者发送的消息并将这些消息路由给服务器中的队列. Exchange有4种类型：direct(默认), fanout, topic, 和headers, 不同类型的Exchange转发消息的策略有所区别
- Queue: 消息队列, 用来保存消息直到发送给消费者. 它是消息的容器也是消息的终点. 一个消息可投入一个或多个队列. 消息一直在队列里面等待消费者连接到这个队列将其取走
- Binding: 绑定, 用于消息队列和交换器之间的关联. 一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则, 所以可以将交换器理解成一个由绑定构成的路由表. Exchange和Queue的绑定可以是多对多的关系
- Connection: 网络连接, 比如一个TCP连接
- Channel: 信道, 多路复用连接中的一条独立的双向数据流通道. 信道是建立在真实的TCP连接内的虚拟连接, AMQP命令都是通过信道发出去的, 不管是发布消息、订阅队列还是接收消息, 这些动作都是通过信道完成. 因为对于操作系统来说建立和销毁TCP都是非常昂贵的开销所以引入了信道的概念以复用一条TCP连接
- Consumer: 消息的消费者, 表示一个从消息队列中取得消息的客户端应用程序
- Virtual Host: 虚拟主机,表示一批交换器、消息队列和相关对象. 虚拟主机是共享相同的身份认证和加密环境的独立服务器域. 每个vhost本质上就是一个mini版的RabbitMQ服务器, 拥有自己的队列、交换器、绑定和权限机制. vhost是AMQP概念的基础, 必须在连接时指定, RabbitMQ 默认的vhost是/
- Broker: 表示消息队列服务器实体
![概念原理](https://github.com/CyS2020/SpringCloud-Mall/blob/main/resources/RabbitMQ%E5%8E%9F%E7%90%86.PNG?raw=true)

#### 4. 