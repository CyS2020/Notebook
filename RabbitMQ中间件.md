### RabbitMQ
#### 1. 消息中间件的应用场景
- 异步处理: 异步任务更快的返回, 剩下任务交给中间件等待消费
- 应用解耦: 不直接依赖接口, 模块可以平滑升级无需重新适配 
- 流量控制: 大并发的场景下全部进来并存入消息队列中, 进行流量削峰

#### 2. 消息中间件概念
- 消息代理: 发消息给消息代理, 取消息从消息代理取, 理解为安装了消息中间件的服务器
- 目的地: 消息代理保证消息传递到指定的目的地, 消息队列主要有两种形式的目的地
    - 队列: 点对点消息通信--消息只有唯一的发送者和接受者(指队列), 但并不是说只能有一个接收者, 谁从队列拿到谁消费
    - 主题: 发布(publish)/订阅(subscribe)消息通信--消息发送到主题, 监听该主题的接收者都能收到这个消息, 都能消费
- JMS(JAVA消息服务): 基于JVM消息代理规范, ActiveMQ、HornetMQ是JMS实现
- AMQP(高级消息队列协议): 也是一个消息代理的规范, 兼容JMS, RabbitMQ是AMQP的实现

#### 3. RabbitMQ概念
- Message: 消息是不具名的, 它由消息头和消息体组成. 消息体是不透明的, 而消息头则由一系列的可选属性组成. 这些属性包括routing-key(路由键)、priority(相对于其他消息的优先权)、delivery-mode(指出该消息可能需要持久性存储)等
- Publisher: 消息的生产者, 也是一个向交换器发布消息的客户端应用程序
- Exchange: 交换器, 用来接收生产者发送的消息并将这些消息路由给服务器中的队列. Exchange有4种类型：direct(默认), fanout, topic, 和headers, 不同类型的Exchange转发消息的策略有所区别
- Queue: 消息队列, 用来保存消息直到发送给消费者. 它是消息的容器也是消息的终点. 一个消息可投入一个或多个队列. 消息一直在队列里面等待消费者连接到这个队列将其取走
- Binding: 绑定, 用于消息队列和交换器之间的关联. 一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则, 所以可以将交换器理解成一个由绑定构成的路由表. Exchange和Queue的绑定可以是多对多的关系
- Connection: 网络连接, 比如一个TCP连接
- Channel: 信道, 多路复用连接中的一条独立的双向数据流通道. 信道是建立在真实的TCP连接内的虚拟连接, AMQP命令都是通过信道发出去的, 不管是发布消息、订阅队列还是接收消息, 这些动作都是通过信道完成. 因为对于操作系统来说建立和销毁TCP都是非常昂贵的开销所以引入了信道的概念以复用一条TCP连接
- Consumer: 消息的消费者, 表示一个从消息队列中取得消息的客户端应用程序
- Virtual Host: 虚拟主机,表示一批交换器、消息队列和相关对象. 虚拟主机是共享相同的身份认证和加密环境的独立服务器域. 每个vhost本质上就是一个mini版的RabbitMQ服务器, 拥有自己的队列、交换器、绑定和权限机制. vhost是AMQP概念的基础, 必须在连接时指定, RabbitMQ 默认的vhost是`/`
- Broker: 表示消息队列服务器实体
![概念原理](https://github.com/CyS2020/SpringCloud-Mall/blob/main/resources/RabbitMQ%E5%8E%9F%E7%90%86.PNG?raw=true)

#### 4. Exchange类型
- direct: 单播模式, 消息中的路由键(routing key)如果和Binding中的binding key一致, 交换器就将消息发到对应的队列中, 路由键与队列名完全匹配
- fanout: 广播模式, fanout交换器不处理路由键, 只是简单的将队列绑定到交换器上, 每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上
- topic: 自定义模式, topic交换器通过模式匹配分配消息的路由键属性, 将路由键和某个模式进行匹配, 此时队列需要绑定到一个模式上. 单词之间用点隔开, 它同样也会识别两个通配符: `# *`

#### 5. 消息确认
- 可靠抵达-ConfirmCallback
    - 消息只要被broker接收到就会执行confirmCallback, 如果是cluster模式, 需要所有broker接收到才会调用confirmCallback
    - 被broker接收到只能表示message已经到达服务器, 并不能保证消息一定会被投递到目标queue里, 所以需要用到接下来的returnCallback
- 可靠抵达-ReturnCallback
    - 如果未能投递到目标queue里将调用returnCallback, 可以记录下详细到投递数据, 定期的巡检或者自动纠错都需要这些数据
- 可靠抵达-Ack消息确认机制
    - 默认自动ack, 消息被消费者收到, 就会从broker的queue中移除
    - queue无消费者, 消息依然会被存储, 直到消费者消费
    - 消费者收到消息, 默认会自动ack. 但是如果无法确定此消息是否被处理完成, 或者成功处理, 我们可以开启手动ack模式
    - 消息处理成功, ack(), 接受下一个消息, 此消息broker就会移除
    - 消息处理失败, nack()/reject(), 重新入队发送给其他人进行处理, 或者容错处理后ack
    - 消息一直没有调用ack()/nack()方法, broker认为此消息正在被处理, 不会投递给别人, 此时客户端断开, 消息不会被broker移除, 会投递给别人

#### 6. 手动确认
- 监听的方法内部必须使用channel进行消息确认, 包括消费成功或消费失败
- 如果不手动确认, 也不抛出异常, 消息不会自动重新推送(包括其他消费者), 因为对于rabbitmq来说始终没有接收到消息消费是否成功的确认, 并且Channel是在消费端有缓存的, 没有断开连接
- 如果rabbitmq断开, 连接后会自动重新推送(不管是网络问题还是宕机)
- 如果消费端应用重启, 消息会自动重新推送; 如果消费端处理消息的时候宕机, 消息会自动推给其他的消费者
- 如果监听消息的方法抛出异常, 消息会按照listener.retry的配置进行重发, 但是重发次数完了之后还抛出异常的话, 消息不会重发(也不会重发到其他消费者), 
只有应用重启后会重新推送. 因为retry是消费端内部处理的, 包括异常也是内部处理, 对于rabbitmq是不知道的
- spring.rabbitmq.listener.retry配置的重发是在消费端应用内处理的, 不是rabbitmq重发
- 消息监听内的异常处理有两种方式:
  - catch异常后, 手动发送到指定队列, 然后使用channel给rabbitmq确认消息已消费
  - 给Queue绑定死信队列, 使用nack(requque为false)确认消息消费失败
- 参考文献: `https://my.oschina.net/dengfuwei/blog/1595047`

#### 7. 如何保证消息可靠性-消息丢失
- 消息发送出去, 由于网络问题没有抵达服务器
  - 做好容错方法(try-catch), 发送消息可能会网络失败, 失败后要有重试机制, 可记录到数据库, 采用定期扫描重发的方式
  - 做好日志记录, 每个消息状态是否都被服务器收到都应该记录(给数据库保存每个消息的详细信息)
  - 做好定期重发, 如果消息没有发送成功, 定期去数据库扫描未成功的消息进行重发
- 消息抵达Broker, Broker要将消息写入磁盘(持久化)才算成功. 此时Broker尚未持久化完成, 宕机. 
  - publisher也必须加入确认回调机制, 确认成功的消息, 修改数据库消息状态. 生产者要确保消息成功抵达
- 自动ACK的状态下. 消费者收到消息, 但没来得及处理消息然后宕机
  - 一定开启手动ACK, 消费成功才移除, 失败或者没来得及处理就noAck并重新入队. 消费者要确保消息成功消费
  
#### 8. 如何保证消息可靠性-消息重复
- 消息消费成功, 事务已经提交, ack时, 机器宕机. 导致没有ack成功, Broker的消息重新由unack变为ready, 并发送给其他消费者
- 消息消费失败, 由于重试机制, 自动又将消息发送出去, 这种情况是允许的
- 成功消费, ack时宕机, 消息由unack变为ready, Broker又重新发送. 如下解决方案:
  -消费者的业务消费接口应该设计为幂等性的. 比如扣库存有工作单的状态标志
  - 使用防重表(redis/mysql), 发送消息每一个都有业务的唯一标识, 处理过就不用处理
  - rabbitMQ的每一个消息都有redelivered字段, 可以获取是否是被重新投递过来的, 而不是第一次投递过来的
  
#### 9. 如何保证消息可靠性-消息积压
- 消费者宕机积压、消费者消费能力不足积压
- 发送者发送流量太大
  - 上线更多的消费者, 进行正常消费
  - 上线专门的队列消费服务, 将消息先批量取出来, 记录数据库, 离线慢慢处理
