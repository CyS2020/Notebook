## 多线程并发编程

### 概念

-   CAS : Compare And Swap 无锁优化——自旋
-   CAS全称是Compare and Swap，即比较并交换，是通过原子指令来实现多线程的同步功能，
    将获取存储在内存地址的原值和指定的内存地址进行比较，只有当他们相等时，交
    换指定的预期值和内存中的值，这个操作是原子操作，若不相等，则重新获取存储在内存地址的原值。
-   cas(V, Expected, NewValue){
        if V == E
           V = NewValue
        otherwise try or fail
    }
    
-   LongAdder使用的是分段锁，效率比AtomicXxx、synchronized高
-   当LongAdder不存在并发访问的时候，会直接通过cas的方式更新base的值，存在并发访问时，会定位到某一个cell，修改cell的value。
    
-   CPU源语支持CAS操作是CPU指令级别的操作中间不能被打断

-   凡是Atomic开头的都是通过CAS来保证线程安全的类

-   ABA : 中间经历B又回到了A，基本数据类型这种可以不管，引用的话添加version号

-   lock cmpxchg 指令

-   Object o = new Object() 在内存中占用16个字节
    
    -   markword占8字节，指针压缩classpoint4字节，不压缩8字节，对齐字节整除8
    
-   上锁过程 ： new 0 0 1-> 偏向锁 1 0 1 -> 轻量级锁（无锁，自旋锁，自适应锁 0 0）->  重量级锁 1 0 -> GC标记信息 1 1
    -   标签一贴，偏向锁
    -   CAS方式多个线程一起贴标签，轻量级锁，不断的循环贴
    -   竞争激烈申请大锁，其他人进入这把锁的等待队列
    -   轻量级锁在用户态，重量级锁在内核态
    
-   自旋锁：占用CPU不访问操作系统，所以是用户态，不经过内核态
-   自旋锁与OS锁：执行时间长、线程数量多的用OS锁，执行时间特别短、线程数量少用自旋锁

-   锁消除：如果检测到不可能共享的资源，自动消除内部的锁

-   锁粗化：JVM检测到一连串的操作会对同一个对象加锁，就会把锁加到循环外面去

-   JIT ：Just In Time Compiler 即时编译器，热点代码直接编译成机器语言

-   超线程：一个ALU对应多个PC、Registers，所谓四核八线程

-   cache line ：64字节

-   MESI Cache 一致性协议：Modified Exclusive Share Invalid

-   乱序执行：读指令的同时可以同时执行不影响的其他指令，而写同时可以进行合并写

-   对象创建过程：new #2 <T>, invokespecial #3 <<T.init>>, astore_1

-   内存屏障：屏障两端指令不允许发生重排

-   volatile：保证线程可见性，一个线程改了另一个需要知道、禁止指令重排序
-   volatile：程序中最好不用，要用的话尽量修饰简单的类型，而不是引用类型

-   volatile：JVM负责加内存屏障，操作系统负责实现内存屏障lock指令
    -   代码中：volatile i
    -   字节码中：ACC_VOLATILE
    -   JVM中：JVM内存屏障，volatile前后屏障
    -   OS中：hotspot实现，锁总线
    
-   强软弱虚：强软和垃圾回收有关，没有空间了欺负软的，弱引用看见了就回收，虚就是虚无的意思
    -   WeakReference
    -   SoftReference
    -   PhantomReference

-   ThreadLocal：和相关线程绑定，线程里有个map，key就是指ThreadLocal，value是指我们set的对象
               线程对象中有一个map:threadLocals对象，负责存ThreadLocal和set的对象
               ThreadLocal t1.set()方法执行时候，t1指向ThreadLocal，map中弱引用指向Entry.key即也是ThreadLocal

-   sheep:  睡一会，让其他线程执行
-   yield:  让一下，让其他线程有机会执行
-   join:   加一下，等待其他线程执行结束

-   线程状态迁移、new、runnable: ready、running、timedwaiting、waiting、blocked、terminate

-   synchronized(this)与public synchronized void method()是等值的
-   synchronized(T.class)与public synchronized static void method()是等值的
-   synchronized既保证了原子性又保证了可见性，锁的是对象不是代码
-   synchronized可重入：重复获得一把锁，不可重入的话一个对象两个方法m1调m2,那就会死锁

-   synchronized(object)
    -   mardword 记录这个线程ID(偏向锁)
    -   如果线程争用升级为自旋锁
    -   自旋10次以后，升级为重量锁 - OS
-   synchronized(object)中不能使用String常量、Integer、Long等基础类型
-   synchronized能够保证有序性、原子性、可见性

-   异常与锁：程序中出现异常的情况，默认情况下，锁会被释放

-   ReentrantLock重入锁，synchronized肯定是可以重入的，所以synchronized可以调用synchronized方法
-   可以使用tryLock尝试锁定，根据返回值判断是否锁定，或者指定tryLock的时间，
-   使用lockInterruptibly() interrpt()，线程锁可以被打断的，也可以指定公平锁true，默认非公平
-   可以和Condition搭配使用，Condition的本质就是等待队列，一个Condition就是一个等待队列   

-   ReentrantLock vs synchronized
    -   CAS vs sync
    -   tryLock
    -   lockInterruptibly
    -   公平和非公平
    
-   乐观锁(CAS), 悲观锁(synchronized), 自旋锁(CAS), 读写锁, 分段锁(ConcurrentHashMap)

-   CountDownLatch，递减门栓，await()用来等待所有线程结束
-   CyclicBarrier，循环栅栏，await()等到凑齐特定线程就推到栅栏
-   Phaser，onAdvance(), arriveAndAwaitAdvance()多个阶段的栅栏
-   ReentrantReadWriteLock，读写锁，readLock()，writeLock()
-   Semaphore，信号量，acquire()，release()，用来限流，同时执行数量
-   Exchanger，exchange()，线程之间交换数据用的，该方法是阻塞的
-   LockSupport，park()当前线程阻塞，unpark()继续运行
-   Lock，notify()，不释放锁，await()，会让出锁

-   模板方法：父类中规定好处理的逻辑，并调用父类定义的方法实现操作模板，等待子类具体实现

-   CallBack Function：父类中调用了一些父类中定义的方法，但是等待将来子类去实现的方法
-   这些父类的方法叫钩子，也称钩子函数，钩着子类的实现，实际用的是子类

-   公平与非公平：当新来的线程要获得锁的时候，检查等待队列有没有线程如果有则排队——公平
              新来的线程上来就抢锁，抢到了就算我的，抢不到就老老实实的排队——非公平
              
-   AQS(AbstractQueuedSynchronizer):volatile-state(子类决定state含义)
-   AQS中维护了一个队列(双向链表)，队列中每个node保存一个线程
-   CAS来设置state的值(即获取锁操作),CAS来设置进入队列的操作 

### 面试问题

-   synchronized实现过程
    -   java代码：synchronized
    -   monitorenter moniterexit
    -   执行过程中自动升级
    -   lock comxchg
     
- synchronized与ReentrantLock有什么不同
    -   synchronized系统自动加锁自动解锁，ReentrantLock手动加锁手动解锁
    -   ReentrantLock可以有不同的Condition对应不同的等待队列
    -   ReentrantLock默认是CAS实现，而synchronized默认进行四种锁状态升级

