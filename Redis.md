### Redis
1. 在客户端与存储层中添加一层缓存层，当客户端在发送请求的时候，会先去缓存层查询，如果有直接返回
如果缓存层没有，则去存储层查--缓存穿透，将结果回写到缓存层--缓存回种，回种之后将结果返回至客户端
当存储层挂掉或者没有办法提供服务的时候，直接将客户端的请求直接打在缓存上--熔断，不管有没有数据直接返回

2. Memcache和Redis的区别
- Memcache: 代码层次类似Hash, 支持简单数据类型, 不支持数据持久化存储, 不支持主从, 不支持分片
- Redis: 数据类型丰富, 支持数据磁盘持久化存储, 支持主从同步, 支持分片

3. 为什么Redis能这么快
- 十万+QPS(QPS即query per second, 没秒内查询次数)
- 完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高，单进程单线程的KV数据库，由C语言编写
- 数据结构简单，对数据操作也简单，存储结构是键值对
- 采用单线程，单线程也可以处理高并发请求，想多核也可以启动多实例
- 使用多路I/O复用模型，非阻塞IO

4. 多路I/O复用模型
- FD: File Descriptor(文件描述符)一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射
- Redis采用的I/O多路复用函数：epoll/kqueue/evport/select
- 因地制宜选择不同的多路复用函数，优先选择复杂度O(1)的I/O多路函数作为底层实现，以时间复杂度为O(n)的select作为保底
- 基于react设计模式监听I/O事件

5. 使用过的Redis数据类型--键值对中的value类型
- String: 最基本的数据类型，二进制安全，保存字符串对象的结构
- Hash: String元素组成的字典，适合用于存储对象
- List: 列表，按照String元素插入顺序排序
- Set: String元素组成的无序集合，通过哈希表实现，不允许重复
- Zset: 通过分数来为集合中的成员进行从小到达的排序.
- 用于计数的HyperLogLog，用于支持存储地理位置信息的Geo
```$xslt
struct sdshdr{
    // buf 中已占用的空间的长度
    int len;
    // buf 中剩余可用的空间长度
    int free;
    // 数据空间
    char buf[];
}
```
6. 底层数据结构基础
- 简单动态字符串；链表；字典；跳跃表；整数集合；压缩表；对象
