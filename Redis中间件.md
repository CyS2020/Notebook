### Redis
#### 1. 概念
在客户端与存储层中添加一层缓存层，当客户端在发送请求的时候，会先去缓存层查询，如果有直接返回
如果缓存层没有，则去存储层查--缓存击穿，将结果回写到缓存层--缓存回种，回种之后将结果返回至客户端
当存储层挂掉或者没有办法提供服务的时候，直接将客户端的请求直接打在缓存上--熔断，不管有没有数据直接返回
缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。
缓存穿透是指缓存中没有数据，数据库中也没有数据，黑客攻击造成数据短时间数据库承受大量请求崩掉

- 解决缓存雪崩
1) 缓存数据设置过期时间设置为随机，防止同一时间大量数据过期现象发生
2) 给每个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效则更新缓存
3) 缓存预热
4) 互斥锁--redis锁

- 解决缓存穿透
1) 接口层增加校验，入用户鉴权校验，id做基础校验
2) 数据库没有的数据将key-value对写为key-null，缓存有效时间设置短一点，因为需要存大量key
3) 采用布隆过滤器bitmap，布隆过滤器说不存在的一定不存在，说存在的可能没有

- 解决缓存击穿
1) 设置热点数据永不过期
2) 互斥锁--redis加锁

#### 2. Memcache和Redis的区别
- Memcache: 代码层次类似Hash, 支持简单数据类型, 不支持数据持久化存储, 不支持主从, 不支持分片
- Redis: 数据类型丰富, 支持数据磁盘持久化存储, 支持主从同步, 支持分片

#### 3. 为什么Redis能这么快
- 十万+QPS(QPS即query per second, 没秒内查询次数)
- 完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高，单进程单线程的KV数据库，由C语言编写
- 数据结构简单，对数据操作也简单，存储结构是键值对
- 采用单线程，单线程也可以处理高并发请求，想多核也可以启动多实例
- 使用多路I/O复用模型，非阻塞IO

#### 4. 多路I/O复用模型
- FD: File Descriptor(文件描述符)一个打开的文件通过唯一的描述符进行引用，该描述符是打开文件的元数据到文件本身的映射
- Redis采用的I/O多路复用函数：epoll/kqueue/evport/select
- 因地制宜选择不同的多路复用函数，优先选择复杂度O(1)的I/O多路函数作为底层实现，以时间复杂度为O(n)的select作为保底
- 基于react设计模式监听I/O事件

#### 5. 使用过的Redis数据类型--键值对中的value类型
- String: 最基本的数据类型，二进制安全，保存字符串对象的结构
- Hash: String元素组成的字典，适合用于存储对象
- List: 列表，按照String元素插入顺序排序
- Set: String元素组成的无序集合，通过哈希表实现，不允许重复
- Zset: 通过分数来为集合中的成员进行从小到达的排序.
- 用于计数的HyperLogLog，用于支持存储地理位置信息的Geo
```$xslt
struct sdshdr{
    // buf 中已占用的空间的长度
    int len;
    // buf 中剩余可用的空间长度
    int free;
    // 数据空间
    char buf[];
}
```

#### 6. 底层数据结构基础
- 简单动态字符串；链表；字典；跳跃表；整数集合；压缩表；对象

#### 7. 从海量Key里查询某一固定前缀的key
- 摸清数据规模，即问清楚边界
- KEYS pattern: 查找符合给定模式pattern的key
- SCAN cursor [MATCH pattern] [COUNT count]
    基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程
    以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历
    不保证每次执行都返回某个给定数量的元素，支持模糊查询
    一次返回的数量不可控，只能是大概率符合count参数
 
#### 8. 如何通过Redis实现分布式锁
- 互斥性，安全性，死锁，容错
- SETNX key value: 如果key不存在，则创建并赋值，返回值：设置成功则为1，设置失败返回0
- EXPIRE key seconds: 设置key的生存时间，当key过期时(生存时间为0)，会被自动删除
- SET key value [EX second] [PX milliseconds] [NX|XX]
    EX second: 设置键的过期时间为second秒
    PX millisecond: 设置键的过期时间millisecond毫秒
    NX: 只有键不存在时，才对键进行设置
    XX: 只有键已经存在时，才对键进行设置
    SET操作成功完成时，才返回OK，否则返回nil

#### 9. 大量的key同时过期的注意事项
- 集中过期，由于清除大量的key很耗时，会出现短暂的卡顿现象
- 解决方案：在设置key的过期时间的时候，给每个key加上随机值

#### 10. 如何使用Redis做异步队列
- 使用List作为队列，RPUSH生产消息，LPOP消费消息
- 缺点：LPOP是不等待队列有值才消费的，可以通过在应用层引入Sleep机制调用LPOP重试
- BLPOP key [key...] timeout: 阻塞队列到队列有消息或者超时
- 缺点：只能供一个消费者消费
- pub/sub: 主题订阅者模式便可实现一(生产者)对多(消费者)的消费队列
- 发送者(pub)发送消息，订阅者(sub)接收消息，订阅者可以订阅任意数量的频道
- 缺点：消息的发布是无状态的，无法保证是否被接收到

#### 11. Redis如何做持久化
- RDB(快照)持久化：保存某个时间点的全量数据快照
- save 300 10 :该配置300秒内有10条写入就进行备份，多种配置规则平衡性能与数据安全
- stop-writes-on-bgsave-error yes :该配置备份进程出错时，主进程停止写入，保护持久化数据一致性
- rdbcompression no : RDB文件无需压缩直接保存，CPU比较珍贵
- SAVE :该命令阻塞Redis的服务器进程，直到RDB文件被创建完成为止
- BGSAVE : Fork出一个子进程来创建RDB文件，不阻塞服务器进程
- RDB持久化缺点：内存数据的全量同步，数据量大会由于I/O而严重影响性能
- 可能会因为Redis挂掉而丢失当前至最近一次快照的期间的数据

- AOF持久化：保存写状态，备份数据库接收到的指令
- 记录下除了查询以外的所有变更数据库状态的指令，以append的形式追加保存到AOF文件中(增量)
- 默认是关闭的，可以通过 appendonly yes 来开启AOF持久化，通过 appendfsync everysec 每隔一秒写入到aof文件里
- 日志重写解决aof文件大小不断增大的问题
- 调用fork()，创建一个子进程，子进程把新的aof写到一个临时文件里，不依赖原来的aof文件
- 主进程持续将新的变动同时写到内存里和原来的aof文件中
- 主进程获取子进程重写aof的完成信号，往新的aof同步增量变动，使用新的aof文件替换掉旧的aof文件

- RDB-AOF混合持久化方式
- 先使用RDB恢复全量数据，在通过AOF恢复增量数据
- BGSAVE做镜像全量持久化，AOF做增量持久化

#### 12. 自动化触发RDB持久化的方式
- 根据redis.conf配置里的SAVE m n定时触发(用的是BGSAVE)
- 主从复制时，主节点自动触发
- 执行Debug Reload的时候
- 执行Shutdown且没有开启AOF持久化

#### 13. Redis数据的恢复
- 如果aof存在则直接加载aof，若不存在则尝试加载RDB文件，如果不存在则启动失败

#### 14. RDB和AOF的优缺点
- RDB优点：全量数据快照，文件小，恢复快
- RDB缺点：无法保存最近一次快照之后的数据
- AOF优点：可读性高，适合保存增量数据，数据不易丢失
- AOF缺点：文件体积大，恢复时间长

#### 15. 使用Pipeline的好处
- Pipeline和Linux的管道类似
- Redis基于请求/响应模型，单个请求处理需要一一应答，Pipeline批量执行指令，节省多次IO往返的时间
- 有顺序的依赖的指令建议分批发送

#### 16. Redis的同步机制
- 主从同步原理：弱一致性(即最终一致性)，不需要保证主从之间实时同步，在过了一段时间之后，他们的数据是趋于同步的
主节点进行BGSAVE生成RDB文件，并将后续的操作记录在内存中，生成的RDB文件同步到从节点，在将期间的操作同步到从节点
- 所有写操作都是在主节点进行的，所有读操作都是在从节点进行的，用户的写操作需要及时的扩散到从节点，保持数据最大程度上的同步
- 主从机制的缺点就是当主节点挂掉之后，无法对外提供写操作，因此Sentinel应用而生

#### 17. 全同步过程
- Slave发送sync命令到Master
- Master启动一个后台进程，将Redis的数据快照保存到文件中
- Master将保存数据快照期间接收到的写命令缓存起来
- Master完成写RDB文件操作后，将该文件发送给Slave
- Slave接收到文件后保存在磁盘中，并加载数据到内存中恢复数据快照
- Master将这期间收集到的增量写命令发送给Slave

#### 18. 增量同步过程
- Master接收到用户的操作指令，判断是否需要同步到Slave
- 将操作记录追加到AOF文件
- 将操作同步到其他Slave : 1. 对齐主从库；2. 往响应缓存写入指令
- 将缓存中的数据发送给Slave(用户执行的命令发送到所有的slave服务器)

#### 19. Redis Sentinel
- 解决主从同步Master宕机后的主从切换问题
- 监控：检查主从服务器是否正常运行
- 提醒：通过API向管理员或者其他应用程序发送故障通知
- 自动故障迁移：主从切换 : 1. Gossip流言协议来确定主节点是否下线；2. 使用投票协议来决定是否进行自动故障迁移

#### 20. Gossip流言协议
- 每个节点都随机地域对方通信，最终所有节点的状态达成一致
- 种子节点定期随机想其他节点发送节点列表，以及需要传播的消息
- 不保证信息一定会传递给所有节点，但最终会趋于一致

#### 21. Redis的集群原理
- 数据分片：按照某种规则去划分数据，分散存储在多个节点上
- 常规的按照哈希划分无法实现节点的动态增减
- 采用一致性哈希算法: 对2^32取模，将哈希值空间组织成一个虚拟的圆环
- 服务器根据主机名或者Ip地址，使用Hash函数计算哈希值，确定服务器在哈希环上的位置
- 对数据key使用相同的函数Hash计算出哈希值，去定位相应的服务器，沿环顺时针遇到的第一个服务器即目标服务器
- 增减减少服务器都只影响哈希环空间的一小部分数据，具有较好的容错性和扩展性
- Hash环的数据倾斜问题，引入虚拟节点解决数据倾斜问题，为一个服务器计算多个虚拟节点，实际虚拟节点设置为32

#### 22. 缓存一致性问题
- 先更新数据库，再更新缓存场景，缓存可能更新失败，读到老数据
- 先更新缓存，再更新数据库场景，写库失败，而缓存是写库失败的数据
- 先删除缓存，再更新数据库的场景，读操作可能会将旧数据读回缓存
- 先更新数据库，再删除缓存场景（推荐使用），也会缓存删除失败的可能
- 延时双删：先删redis，在更新数据库，休眠1s，再次删除缓存
- 最佳实现，数据异步同步：mysql会将操作记录在Binary log日志中，通过canal去监听数据库日志二进制文件，解析log日志，同步到redis中进行增删改操作。

#### 23. 缓存过期策略有哪些
- 定时过期：每个设置时间的key都需要创建一个定时器，到过期时间就立即清除；利好内存，消耗CPU
- 惰性过期：只有当访问一个key时判断key是否过期，过期则清除；利好CPU，消耗内存
- 定期过期：每隔一定时间，会扫描一定数量的数据库的expires字典中一定数量的key(随机的)，折中方案
- redis主要是惰性过期和定期过期两种方案

#### 24. 缓存淘汰算法
- FIFO--先进先出；LRU--最近最少使用；LFU--最不经常使用

#### 25. 服务降级，熔断
- 降级是解决系统资源不足和海洋业务请求之间的矛盾，对非核心业务，非关键业务，进行有策略的放弃，释放系统资源
- 熔断模式保护业务系统不被外部大量流量或者下游系统的异常拖垮

