### 设计模式

#### 设计模式原则
- 单一职责原则：即一个类只负责一项职责，代码中大量if else逻辑
- 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能
- 依赖倒置原则：核心思想是面向接口编程
- 接口隔离原则：细化接口，同时注意接口设计的过大或过小都不好
- 迪米特法则：只与直接的朋友通信，局部变量中的类则不是直接的朋友，陌生的类最好不要作为局部变量的形式出现在类的内部
- 开闭原则：用抽象构建框架，用实现扩展细节；扩展开放，对修改关闭
- 组合/聚合复用原则：组合或者聚合好过于继承

#### 策略模式
- 设计原则：
  - 找到应用中课能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
  - 针对接口编程，而不是实现编程；变量的声明类型应该是超类型(抽象类/接口)，利用多态特性
  - 多用组合，少用继承；“有一个”可能比“是一个”更好；组合具体行为符合正确接口标准
- 设计过程：
  - 将变化的行为或功能(算法族)，抽象为接口；并封装到类中；实现接口传入具体功能，运行时绑定具体方法
  - 策略模式感觉是对if-else、switch-case这类分支结构的解耦，把每一种情况封装成一种策略，实现代码简化
  - 策略模式更倾向于算法的互相替换，对象使用组合更有弹性
- 策略模式--定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户

#### 观察者模式
- 设计原则：
  - 为交互对象之间的松耦合设计而努力
- 设计过程：
  - 主题 + 观察者 = 观察者模式；
  - 主题对象管理某些数据，主题对象数据改变，就会通知观察者，观察者在数据改变时能收到更新
  - 自定义实现：主题对象拥有数据及观察者列表，观察者对象拥有观察的内容(可以拥有主题对象方便取消订阅)
  - java内置实现：主题对象继承Observable类，观察者实现Observer接口；
  - 两种方式均是在观察者构造器中进行订阅，且原理相同；建议使用自定义实现：主题、观察者均先定义接口然后编写实现类
  - 消息通知方式有push与pull两种形式，主题push在update时直接传入观察的数据，观察者pull在update时传入主题，数据从主题中自定义获取；pull的形式观察内容可以不一致
- 观察者模式--在对象之间定义“一对多”的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自动更新

#### 装饰者模式
- 设计原则：
  - 类应该对扩展开放，对修改关闭
- 设计过程：
  - 装饰者和被装饰者对象有相同的超类型，可以用一个或多个装饰者包装一个对象
  - 既然装饰者和被装饰者对象有相同的超类型，所以在任何需要原始对象(被包装的)场合，可以用装饰过的对象代替它
  - 对象可以再任何时候被装饰，所以可以再运行时动态地、不限量地用你喜欢的装饰者来装饰；就是套娃
  - 装饰者可以再被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而到达特定的目的
  - 装饰者对象拥有被装饰者对象；装饰者继承抽象装饰者，抽象装饰者继承超类型(三层)；被装饰者继承超类型(两层)
  - java内部案例：InputStream -> FilterInputStream(InputStream) -> BufferedInputStream
- 装饰者模式--动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案

#### 工厂模式
- 设计原则：
  - 要依赖抽象，不要依赖具体类
  - 变量不可以持有具体类的引用
  - 不要让类派生自具体类，请派生自一个抽象
  - 不要覆盖基类中已实现的方法
- 设计过程：
  - 识别变化部分与不变的部分，**封装变化**；变化的对象创建抽象为工厂方法
  - 静态方法定义一个简单工厂称为静态工厂，但不能通过继承来改变方法的行为
  - 工厂方法用来处理对象的创建，并将这样的行为封装在子类中；超类拥有处理这类对象的最一般的方法；超类中的工厂方法是抽象的
  - 所有工厂模式都用来封装对象的创建，让子类决定该创建的对象，来达到将对象创建的过程封装的目的
  - 参数化工厂中子类中具体的种类创建还是会遇到if/else/switch等逻辑；然而通常工厂只生产一种对象
- 工厂模式--定义了一个创建对象的接口，但是由子类决定要实例化的类是哪一个，工厂方法让类的实例化推迟到子类

#### 抽象工厂
- 设计过程：
  - 抽象工厂声明了一组创建各种抽象产品的方法，具体工厂实现抽象工厂的接口创建具体的产品
  - 客户端依赖抽象工厂与抽象产品，在初始化客户端类时传入具体工厂
  - 抽象工厂是对对象的管理，作用就是创建不同的对象；策略模式是对行为的管理，作用是一个对象在不同情况选择行为
  - 抽象工厂的方法经常以工厂方法的方式实现，即由子类继承并实现
  - 工厂模式使用子类继承方式创建对象，抽象工厂通过组合方式，作为客户端类的字段，并在客户端类初始化时传入具体工厂
- 抽象工厂--提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

#### 单例模式
- 设计过程：
  - 场景：线程池，缓存，对话框，系统配置，注册表，日志对象，硬件设备驱动程序
  - 单例模式的特性，两个静态(静态字段与获取该字段的方法)，一私有(构造器私有)
  - 线程安全：直接sync同步，饿汉式直接静态初始化，volatile + 双重检查
- 单例模式--确保一个类只有一个实例，并提供全局访问点

#### 命令模式
- 设计过程：
  - 调用者中拥有命令对象，命令对象(实现命令接口的对象)拥有接收者；调用者和接收者解耦
  - 命令对象提供一个执行方法execute，该方法封装了执行动作，这些动作和接收者绑定，接收来负责执行
  - 客户要求调用者执行命令，调用者调用命令对象的执行方法，导致接收者的动作被调用
  - 命令执行者有点像线人的意思，由它负责将调用者想要执行的任务传递给具体接收者。
  - 首长发动进攻命令，情报员通过电台通知各部，则步兵，骑兵，炮兵执行进攻行为，该打枪打枪该突袭突袭该放炮放炮
  - 线程池中的任务队列，线程池调用任务(命令对象)时，任务实现Runnable接口，接收者(内部对象组合)在run方法中执行任务
  - 日志请求将上次检查点后的操作记录下来，便于宕机的数据恢复；mysql根据日志文件主从同步也是这个模式
  - 实际操作时，很常见使用“聪明”命令对象，也就是直接实现了请求，而不是将工作委托给接收者；例如执行任务直接写在run方法里面
- 命令模式--将请求封装成对象，这可以让你使用不同请求、队列，或者日志请求来参数化其他对象；命令模式也支持撤销操作

#### 适配器模式
- 设计过程
  - 包装某些对象让他们看起来不像自己而像别的东西，将一个接口转换成另一个接口
  - 和装饰者差不多，适配器实现期望类型的接口，同时拥有被适配者的对象；装饰者实现期望类型接口，同时拥有被装饰者的对象
  - 被适配者的上层接口与适配器的上层接口并不一致；被装饰的上层接口与装饰者的上层接口是一致的
  - 当被适配者需要同时适配新旧系统，可以创建一个双向适配器，实现涉及的两个接口即可
- 适配器模式--将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间

#### 外观模式
- 设计原则
  - 最少知识原则：只和你的密友谈话(迪米特法则)
  - 任何对象而言，在该对象内的方法，只能调用属于以下范围的方法
    - 该对象本身的方法
    - 被当做方法参数传递进来的对象的方法
    - 此方法所创建或实例化的任何对象的方法
    - 对象拥有的组件的方法(和上一条类似)
  - 除此之外，不要调用以下范围的方法
    - 在方法内部new创建局部对象并调用该对象的方法
    - 方法内部调用其他方法所返回的对象的方法
- 设计过程
  - 将对象包装起来以简化其接口；将一个类或数个类的复杂的一切隐藏在背后，只显露出一个干净简洁的外观
  - 一个适配器适配一个被适配者是适配器模式，一个适配器适配多个被适配者是外观模式
  - 外观模式将各个组件整合成一个统一的接口，就是我们经常编写一个类组合多个类对外提供功能
- 外观模式--提供了一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易使用

#### 模板方法模式
- 设计原则
  - 好莱坞原则：别调用我们，我们会调用你
  - 依赖倒置原则和好莱坞原则均是高级组件用低级组件提供的方法来实现某项功能的
  - 依赖倒置原则是面向低级组件的接口，通过组合的形式持有组件接口进行编程
  - 好莱坞原则是面向抽象接口，低级组件继承并实现具体功能，低级组件挂钩进计算中
- 设计过程
  - 模板方法定义了一个算法步骤，每个步骤对应一个方法，这些方法可以由超类提供，也可以由子类提供，只由子类提供的场景需要在超类型中声明为抽象方法
  - 模板方法规定了一套执行的标准或流程或框架或步骤，具体执行过程由子类提供；在创建框架的时候常用到该设计模式
  - 模板方法将算法定义成一组步骤，其中任何步骤都可以是抽象的，由子类实现，确保算法步骤保持不变
  - 所谓钩子方法是对于抽象方法或者接口中定义的方法的一个空实现，在模板方法执行流程中干预父类模板方法的执行流程，通常返回bool类型进行条件控制
  - 码代码过程中突然需要某个类但又不知道具体的创建方式，直接使用工厂模式；工厂模式是模板方法模式的特殊版本
  - 如果突然觉得某个类应该具备功能(例如sort方法要对象实现Comparable接口)，或者执行特定的操作(遗传算法)但是具体实现方式未知时使用模板方法
  - 策略模式和模板方法模式都是封装算法，一个用组合一个用继承
- 模板方法模式--在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法的情况下，重新定义算法中的某些步骤

#### 迭代器模式
- 设计原则
  - 单一职责告诉我们一个类应该只有一个引起变化的原因
- 设计过程
  - **封装变化**的部分，即向上抽象
  - 迭代器模式依赖一个名为迭代器的接口，java内部的Iterator接口：next(), hasNext(), remove()
  - 迭代器模式让我们能游走与聚合内的每一个元素，而又不暴露其内部的表示
  - 把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所
  - Collection和Iterator的好处在于，每个Collection都知道如何创建自己的Iterator，无需关心具体的容器
  - 一个空迭代器最好不要返回null，而是通过hasNext()永远返回false，客户端无需做null判断
- 迭代器模式--提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部表示

#### 组合模式
- 设计过程
  - 组合模式让我们能用树形方式创建对象的结构，树里面包含了组合以及个别对象，有点像我们的链表，二叉树等数据结构
  - 使用组合模式我们能把相同的操作应用在组合和个别对象上。换句话说在大多数情况下，我们可以忽略对象组合和各别对象之间的差别
  - 组合模式以单一职责原则换取透明性，透明性指客户端代码对组合节点和叶节点一视同仁不会使用instanceof来判断数据的类型
  - 组合结构内的任意对象称为组件，组件可以是组合，也可以是叶节点
- 组合模式--允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象及对象组合

#### 状态模式
- 设计过程
  - 策略模式是围绕可以互换的算法来创建成功业务的，状态模式是通过改变对象内部的状态来帮助对象控制自己的行为
  - 策略模式主动指定Context所要组合的对象；状态模式里组合所有状态的对象，根据状态选择某个对象执行，Context对于状态对象浑然不觉
  - 通常我们的有状态和改变状态的行为，根据封装变化的思想，状态抽象为类，改变状态的行为抽象为类中的方法；共有n * m个方法待实现
  - 状态机组合所有可能出现的状态，并设置一个标志位记录当前状态机所处的状态
  - 定义一个state接口，在这个接口内，状态机的每个动作都有一个对应的方法，然后为每个状态实现状态类，负责对应状态下状态机的行为
  - 所有的状态类都实现了该接口并且都组合到了状态机内，状态之间可以互相替换；状态机记录当前的状态并调用对应状态的方法，使用了多态的特性
- 状态模式--允许对象内部状态改变时改变它的行为，对象看起来好像修改了它的类

#### 代理模式
- 设计过程
  - 代理类通过RMI代理远程的服务，调用本地对象的方法转发给远程对象的方法
  - 使用代理模式创建代表对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象、创建开销大的对象或需要安全控制的对象
  - 代理对象和被代理对象实现了共同的接口，拥有相同的超类型
  - 有点类似装饰者设计模式，一个用于控制对象的访问，一个用于对象增加行为
  - java实现动态代理,cglib代理的对象无需实现接口
    - InvocationHandler的工作是响应代理的任何调用，是代理收到请求后请求做实际工作的对象
    - InvocationHandler只有一个接口`invoke(Object proxy, Method method, Object[] args)`
    - 通过`Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)`创建代理类
- 代理模式--为另一个对象提供一个替身或占位符以控制对这个对象的访问

#### 复合模式
- MVC内设计模式
  - 策略模式：视图是一个对象，可以被调整使用不同的策略即控制器；想换一种行为就换掉控制器
  - 观察者模式：模型作为可观察者，视图控制器等对模型状态改变有兴趣的对象可以注册成为观察者
  - 组合模式：视图是一堆GUI组件，顶层组件包含其他组件直到叶节点；使用组合模式来管理他们
- 复合模式--结合两个或两个以上的模式，组成一个解决方案，解决一再发生的一般性问题

#### 归约
- 本笔记中描述的拥有某个对象，均指的是类中拥有该类型的上层接口作为字段的，面向接口编程
- 本笔记中描述的组合类，均值的是类的超类型，可以是类，抽象类，接口等，面向超类编程
