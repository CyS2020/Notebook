### 设计模式

#### 设计模式原则
- 单一职责原则：即一个类只负责一项职责，代码中大量if else逻辑
- 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能
- 依赖倒置原则：核心思想是面向接口编程
- 接口隔离原则：细化接口，同时注意接口设计的过大或过小都不好
- 迪米特法则：只与直接的朋友通信，局部变量中的类则不是直接的朋友，陌生的类最好不要作为局部变量的形式出现在类的内部
- 开闭原则：用抽象构建框架，用实现扩展细节；扩展开放，对修改关闭
- 组合/聚合复用原则：组合或者聚合好过于继承

#### 策略模式
- 设计原则：
  - 找到应用中课能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
  - 针对接口编程，而不是实现编程；变量的声明类型应该是超类型(抽象类/接口)，利用多态特性
  - 多用组合，少用继承；“有一个”可能比“是一个”更好；组合具体行为符合正确接口标准
- 设计过程：
  - 将变化的行为或功能(算法族)，抽象为接口；并封装到类中；实现接口传入具体功能，运行时绑定具体方法
  - 策略模式感觉是对if-else、switch-case这类分支结构的解耦，把每一种情况封装成一种策略，实现代码简化
- 策略模式--定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户

#### 观察者模式
- 设计原则：
  - 为交互对象之间的松耦合设计而努力
- 设计过程：
  - 主题 + 观察者 = 观察者模式；
  - 主题对象管理某些数据，主题对象数据改变，就会通知观察者，观察者在数据改变时能收到更新
  - 自定义实现：主题对象拥有数据及观察者列表，观察者对象拥有观察的内容(可以拥有主题对象方便取消订阅)
  - java内置实现：主题对象继承Observable类，观察者实现Observer接口；
  - 两种方式均是在观察者构造器中进行订阅，且原理相同；建议使用自定义实现：主题、观察者均先定义接口然后编写实现类
  - 消息通知方式有push与pull两种形式，主题push在update时直接传入观察的数据，观察者pull在update时传入主题，数据从主题中自定义获取；pull的形式观察内容可以不一致
- 观察者模式--在对象之间定义“一对多”的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自动更新

#### 装饰者模式
- 设计原则：
  - 类应该对扩展开放，对修改关闭
- 设计过程：
  - 装饰者和被装饰者对象有相同的超类型，可以用一个或多个装饰者包装一个对象
  - 既然装饰者和被装饰者对象有相同的超类型，所以在任何需要原始对象(被包装的)场合，可以用装饰过的对象代替它
  - 对象可以再任何时候被装饰，所以可以再运行时动态地、不限量地用你喜欢的装饰者来装饰；就是套娃
  - 装饰者可以再被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而到达特定的目的
  - 装饰者对象拥有被装饰者对象；装饰者继承抽象装饰者，抽象装饰者继承超类型(三层)；被装饰者继承超类型(两层)
  - java内部案例：InputStream -> FilterInputStream(InputStream) -> BufferedInputStream
- 装饰者模式--动态地将责任附加到对象上。若要扩展功能，装饰者提供比继承更有弹性的替代方案

#### 工厂模式
- 设计原则：
  - 要依赖抽象，不要依赖具体类
  - 变量不可以持有具体类的引用
  - 不要让类派生自具体类，请派生自一个抽象
  - 不要覆盖基类中已实现的方法
- 设计过程：
  - 识别变化部分与不变的部分，**封装变化**；变化的对象创建抽象为工厂方法
  - 静态方法定义一个简单工厂称为静态工厂，但不能通过继承来改变方法的行为
  - 工厂方法用来处理对象的创建，并将这样的行为封装在子类中；超类拥有处理这类对象的最一般的方法；超类中的工厂方法是抽象的
  - 所有工厂模式都用来封装对象的创建，让子类决定该创建的对象，来达到将对象创建的过程封装的目的
  - 参数化工厂中子类中具体的种类创建还是会遇到if/else/switch等逻辑；然而通常工厂只生产一种对象
- 工厂模式--定义了一个创建对象的接口，但是由子类决定要实例化的类是哪一个，工厂方法让类的实例化推迟到子类

#### 抽象工厂
- 设计过程：
  - 抽象工厂声明了一组创建各种抽象产品的方法，具体工厂实现抽象工厂的接口创建具体的产品
  - 客户端依赖抽象工厂与抽象产品，在初始化客户端类时传入具体工厂
  - 抽象工厂是对对象的管理，作用就是创建不同的对象；策略模式是对行为的管理，作用是一个对象在不同情况选择行为
  - 抽象工厂的方法经常以工厂方法的方式实现，即由子类继承并实现
  - 工厂模式使用子类继承方式创建对象，抽象工厂通过组合方式，作为客户端类的字段，并在客户端类初始化时传入具体工厂
- 抽象工厂--提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类

#### 单例模式
- 设计过程：
  - 场景：线程池，缓存，对话框，系统配置，注册表，日志对象，硬件设备驱动程序
  - 单例模式的特性，两个静态(静态字段与获取该字段的方法)，一私有(构造器私有)
  - 线程安全：直接sync同步，饿汉式直接静态初始化，volatile + 双重检查
- 单例模式--确保一个类只有一个实例，并提供全局访问点