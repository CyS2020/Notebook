### 设计模式

#### 设计模式原则
- 单一职责原则：即一个类只负责一项职责，代码中大量if else逻辑
- 里氏替换原则：子类可以扩展父类的功能，但不能改变父类原有的功能
- 依赖倒置原则：核心思想是面向接口编程
- 接口隔离原则：细化接口，同时注意接口设计的过大或过小都不好
- 迪米特法则：只与直接的朋友通信，局部变量中的类则不是直接的朋友，陌生的类最好不要作为局部变量的形式出现在类的内部
- 开闭原则：用抽象构建框架，用实现扩展细节；扩展开放，对修改关闭
- 组合/聚合复用原则：组合或者聚合好过于继承

#### 策略模式
- 设计原则：
  - 找到应用中课能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
  - 针对接口编程，而不是实现编程；变量的声明类型应该是超类型(抽象类/接口)，利用多态特性
  - 多用组合，少用继承；“有一个”可能比“是一个”更好；组合具体行为符合正确接口标准
- 设计过程：
  - 将变化的行为或功能(算法族)，抽象为接口；并封装到类中；实现接口传入具体功能，运行时绑定具体方法
- 策略模式--定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户

#### 观察者模式
- 设计原则：
  - 为交互对象之间的松耦合设计而努力
- 设计过程：
  - 主题 + 观察者 = 观察者模式；
  - 主题对象管理某些数据，主题对象数据改变，就会通知观察者，观察者在数据改变时能收到更新
  - 自定义实现：主题对象拥有数据及观察者列表，观察者对象拥有观察的内容(可拥有主题对象方便取消订阅)
  - java内置实现：主题对象继承Observable类，观察者实现Observer接口；
  - 两种方式均是在观察者构造器中进行订阅，且原理相同；建议使用自定义实现：主题、观察者均先定义接口然后编写实现类
  - 消息通知方式有push与pull两种形式，主题push在update时直接传入观察的数据，观察者pull在update时传入主题，数据从主题中自定义获取；pull的形式观察内容可以不一致
- 观察者模式--在对象之间定义“一对多”的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自动更新