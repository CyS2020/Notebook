## 代理模式

-   代理模式为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。这样做的好处是：可以再目标对象的基础上，增强额外的功能操作，即扩展目标对象的功能

-   被代理的对象可以是远程对象、创建开销大的对象或者需要安全控制的对象，对对象功能进行增强

-   代理模式有不同的形式，主要有三种 静态代理、动态代理、Cglib代理(可以再内存动态的创建对象，而不需要实现接口，属于动态代理的范畴)


### 静态代理

-   静态代理在使用时，需要定义接口或者父类，被代理对象(即目标对象)与代理对象一起实现相同的接口

-   调用的时候通过调用代理对象的方法来调用目标对象
-   代理对象与目标对象要实现相同的接口，然后通过调用相同的方法来调用目标对象的方法

### 动态代理

-   代理对象不需要实现接口，但是目标对象要实现接口，否则不能用动态代理
-   代理对象的生成，是利用jdk的API，动态的在内存中构建代理对象
-   代理类所在的包：java.lang.reflect.Proxy 需要使用newProxyInstance
-   Classloader loader: 指定当前目标对象使用的类加载器，获取加载器的方法固定
-   Class<?>[] interfaces: 目标对象它实现的接口类型，使用泛型方式确认类型
-   InvocationHandler h: 事件处理，执行代理 对象方法时，会触发事件处理器方法，会把当前执行的目标对象方法作为一个参数传入

### Cglib代理

-   静态代理动态代理都要求目标对象是实现一个接口，但有时候目标对象知识个单独的对象，没有实现任何接口
-   Cglib代理也叫做子类代理，在内存中构建一个子类对象从而实现目标对象功能扩展

-   Cglib是一强大的高性能代码生成包，可以运行期扩展java类与实现java接口，别广泛应用于AOP的框架中
-   AOP编程中如何选择代理模式，目标对象需要实现接口用动态代理，不需要实现接口用Cglib代理
-   Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类
-   需要引入Cglib的jar文件，代理类不能是final的，目标对象的方法如果是final/static那么不会被拦截

### 常见的几种变体

-   防火墙代理
-   缓存代理
-   远程代理
-   同步代理