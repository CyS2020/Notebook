1. TCP简介
- 面向链接的、可靠的、基于字节流的传输层通信协议
- 将应用层的数据流分割成报文段并发送给目标节点的TCP层
- 数据包都有序号，对方收到则发送ACK确认，未收到则重传
- 使用奇偶校验和函数来检验数据在传输过程中是否有误

2. TCP三次握手
- IP地址 + (TCP/UDP)协议 + 端口号 = 网络中的一个进程，该种标识也称Socket
- SYN = 1, seq = x  ---> 客户端进入SYN-SENT状态
- SYN = 1, ACK = 1, seq = y, ack = x + 1 ---> 服务端进入SYN-RECV状态
- ACK = 1, seq = x + 1, ack = y + 1  ---> 客户端进入ESTABLISHED状态
- 服务端接收后也进入ESTABLISHED状态

3. 为什么需要三次握手才能建立连接
- 为了初始化Sequence Number的初始值，通信双方需要互相通知对方并确认对方已经收到

4. 首次握手的隐患-SYN超时
- 服务端收到客户端的SYN，回复SYN-ACK的时候未收到ACK确认，服务端不断重试直至63秒超时
- SYN Flood防范措施：SYN队列满后，tcp_syncookies参数回发SYN Cookie，客户端会回发SYN cookie，从而直接建立连接

5. 建立连接，客户端出现故障怎么办--保活机制
- 想对方发送保活探测报文，如果未收到响应则继续发送
- 尝试次数达到保活探测数仍未收到响应则中断连接

6. TCP四次挥手
- 在socket编程中，客户端与服务端一方执行close来触发
- FIN = 1, seq = u ---> 进入FIN-WAIT-1状态
- ACK = 1, seq = v, ack = u + 1 ---> 进入CLOSED-WAIT状态
- 客户端接收到后进入FIN-WAIT-2 此时服务端数据传送还要持续一段时间
- FIN = 1, ACK = 1, seq = w, ack = u + 1 ---> 进入LAST-ACK
- ACK = 1, seq = u + 1, ack = w + 1 ---> TIME-WAIT
- 服务端接收后进入CLOSED状态，客户端等待2MSL后也进入CLOSED状态，MSL=30s
- 注释：seq是累加的是自己的序号，ack确认的是别人的序号

7. 为什么有TIME_WAIT状态
- 确保有足够的时间让对方收到ACK包
- 避免新旧连接混淆

8. 为什么需要四次挥手才能断开连接
- 因为全双工，发送方和接收方都需要FIN报文和ACK报文
- 发送方和接收方均需两次挥手，只不过有一方是被动的看起来是四次

9. 服务器出现大量CLOSE_WAIT状态原因
- 对方关闭socket连接，我方忙于读写，没有及时关闭连接
- 检查代码，特别是释放资源的代码
- 检查配置，特别是处理请求的线程配置

10. UDP简介
- 面向非连接
- 不维护连接状态，支持同时向多个客户端传输相同的消息
- 数据包报头只有8个字节，额外开销较小
- 吞吐量只受限于数据生成速率、传输速率以及机器性能
- 尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表
- 面向报文，不对应用程序提交的报文信息进行拆分或者合并

11. TCP和UDP的区别
- 都是传输层的传输协议TCP用于可靠的传输，UDP则用于让网络和细节控制交给应用层的通信传输
- 面向连接 vs 无连接，UDP适合消息的多播发布
- 可靠性 = 握手确认 + 重传机制
- 有序性 = 序列号 + 排序
- 速度 TCP < UDP
- TCP重量级，UDP轻量级

12. TCP的滑窗
- RTT: 发送一个数据包到收到对应的ACK，所花费的时间; RTO: 重传时间间隔
- TCP使用滑动窗口做流量控制与乱序重排
- 保证TCP的可靠性; 保证TCP的流控特性
- 报文中window字段用于接收方通知发送方自己还有多少缓冲区可以接收数据

- TCP缓存内数据分类
- TCP会话发送方：已确认 + (已发送 + 允许发送) + 不允许发送; 括号内为发送窗口
- TCP会话接收方：已确认 + (允许接收) + 不允许接收; 括号内为接收窗口
- 滑动窗口大小可以依据一定策略调整：接收端会根据自己处理能力的变化通过window大小设置，来实现限制发送方的流量

13. HTTP简介
- 支持客户/服务器模式，简单快速，灵活，无连接，无状态

14. 请求/响应步骤
- 浏览器连接到web服务器，与端口80建立一个tcp套接字连接
- 发送Http请求，浏览器通过套接字向服务器发送文本的请求报文
- 服务器接收请求并返回HTTP响应，web服务器解析请求定位请求资源，将资源副本写入套接字由客户端读取
- 释放TCP连接，服务端主动关闭连接，客户端被动关闭连接
- 浏览器解析HTML内容

15. 在浏览器地址栏键入URL，按下回车之后经历的流程
- DNS解析，根据URL逐层查询DNS缓存解析域名对应的IP地址，
由近及远：浏览器缓存 -> 系统缓存 -> 路由器缓存 -> IPS网路运营商缓存 -> 域名服务器缓存 -> 顶级域名服务器缓存
- TCP连接
- 发送HTTP请求
- 服务器处理请求并返回HTTP报文
- 浏览器解析渲染页面
- 连接结束释放TCP连接

16. HTTP状态码
- 1xx: 指示信息--表示请求已接收，继续处理
- 2xx: 成功--表示请求一杯成功接收、理解、接受
- 3xx: 重定向--要完成请求必须进行更进一步的操作
- 4xx: 客户端错误--请求有语法错误或请求无法实现
- 5xx: 服务端错误--服务端未能实现合法的请求

- 200 OK: 正常返回信息
- 400 Bad Request: 客户端请求有语法错误，不能被服务器理解
- 401 Unauthorized: 请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用
- 403 Forbidden: 服务器收到请求，但是拒绝提供服务
- 404 Not Found: 请求资源不存在，eg，输入了错误的URL
- 500 Internal Server Error: 服务器发生不可预测的错误
- 503 Server Unavailable: 服务器不能处理当前客户端的请求，一段时间后可能恢复正常
 
17. GET请求和POST请求的区别
- Http报文层面：GET请求信息放在URL后，请求信息为?后面的键值对，POST将请求信息放置在报文体中
- 数据库层面：GET符合幂等性和安全性，POST不符合
- 其他层面：GET可以被浏览器缓存、被存储，而POST不行

18. Cookie和Session的区别
- Cookie数据存放在客户端的浏览器上，Session数据放在服务器上
- Session相对于Cookie更安全
- 若考虑减轻服务器负担，应当使用Cookie

- Cookie: 客户端机制，由服务器发给客户端的特殊信息，以文本的形式存放在客户端
当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息，并且提交至服务器，
紧接着服务器在响应客户端请求发送超文本，也会发回根据个人信息生成的Cookie(存放在HTTP响应头中)，当客户端接收到服务端的响应之后，
浏览器会将这些信息存放在统一的位置，客户端再次请求的时候，会把Cookie发回服务器(存放在HTTP请求头中)，
服务器接收到后，回解析Cookie生成与客户端相对应的内容，用户不需要重复输入个人信息
- Cookie的设置及发送过程:
Client  ---         HTTP Request      ---> Server
Client <--- HTTP Response + Set-Cookie --- Server
Client  --- HTTP Request + Cookie     ---> Server
Client <---         HTTP Response      --- Server
           
- Session: 服务端机制，服务器使用了一种类似散列表的结构来保存信息
当服务器需要为某个客户端请求创建一个Session的时候，服务器检查请求中是否包含了Session标识即session id
则说明以前已经为此客户端创建了Session，服务器则通过session id检索出Session信息来使用，如果检索不到就新建一个Session
如果客户端请求不包含Session id则为此客户端创建一个Session，并且生成一个相对应的session id，在本次响应中回发给客户端
- Session实现方式1: 使用Cookie来实现，服务器给每个Session分配一个将JSESSIONID存放在Cookie中发给客户端
客户端发起新的请求的时候将在Cookie头中携带JSESSIONID，服务器就能找到与客户端对应的Session
- Session实现方式2: 使用URL会回写来实现，服务器在发送给浏览器的所有页面中都携带JSESSIONID参数，这样浏览器点击任何链接
均会把JSESSIONID带回服务器，如果在浏览器输入服务端资源的URL请求该资源，那么Session是找不到的

- Token: 客户端机制，有服务器发给客户端的信息，客户端以cookie或sessionStorage或localStorage对token进行存储。无状态
- 客户端登录成功后，服务器会对用户信息(非敏感)进行签名，根据规则生成token返回给客户端，但服务器不保存token
- 客户端再次请求时不会默认携带，需要在请求头中添加认证字段Authorization并携带token信息
- 对客户端传来的token进行验证，如果计算后的签名和带来的签名相同， 就知道用户已经登录过了，并且可以直接取出token中信息进行使用
- 如果不相同， 数据部分肯定被人篡改过，我就告诉发送者：对不起，没有认证。
- 这样一来，我就不保存session id了，我只是生成token，然后验证token，我用我的CPU计算时间获取了我的session存储空间
- 了解jwt token: `https://www.cnblogs.com/better-farther-world2099/p/9146143.html`

- 区别session与会话状态密切相关，简单来说就是，关掉这次会话后就会消失，例如关闭浏览器。
- 由于浏览器发送请求会将cookie带上, 后端不会认证因此会造成CSRF攻击, 使用token是请求头需要Authorization字段后端进行验证; 
- cookie与sessionStorage或localStorage, 不同源不能共享数据无法再请求头中添加Authorization字段避免CSRF攻击
- 服务端不需要缓存用户信息，减少服务器压力
- token缓存在客户端，服务器重启，登录状态不会失效
- session是浏览器特有的，app要支持会比较繁琐，token就没有这样的限制
- 易于扩展，存在多台服务器的情况下，使用负载均衡
- 更安全，发送token能够防止CSRF(跨站请求伪造)

19. HTTP与HTTPS的区别
- HTTPS需要到CA申请证书，HTTP不需要
- HTTPS密文传输，HTTP明文传输
- 连接方式不同，HTTPS默认使用443端口，HTTP默认使用80端口
- HTTPS = HTTP + 加密 + 认证 + 完整性保护，叫HTTP安全

- HTTPS: 超文本传输安全协议，在HTTP与TCP之间添加了一层SSL(安全套接字层)
- SSL: 为网络通信提供安全及数据完整性的一种安全协议，是操作系统对外的API，采用身份验证和数据加密保证网络和数据的完整性
- 加密方式：对称加密--加密和解密都是同一个密钥; 非对称加密--加密(公钥)和解密(私钥)使用的密钥是不相同的; 
哈希算法--任意长度信息转换为固定长度的值MD5算法; 数字签名--证明某个消息或者文件时某个人发出/认同的
- 公钥加密处理起来比对称加密方式复杂，HTTPS采用混合加密机制，使用公钥加密方式握手交换对称加密密钥，使用对称加密方式通信

- HTTPS数据传输流程
浏览器将支持的加密算法信息发送给服务器，服务器选择一套浏览器支持的加密算法，以证书的形式发送给浏览器，
证书里包含了证书发布的机构、证书的有效期、公钥、证书所有者、还有签名等，浏览器收到证书后首先验证证书的合法性
并结合证书公钥加密信息生成对称密钥发送给服务器，服务器使用私钥解密信息确定对称密钥，并计算验证哈希与浏览器一致
保证数据完整性，使用对称密钥加密响应消息回发浏览器，浏览器使用对称密钥解密响应消息，验证哈希与服务器一致，
之后使用对称加密交互数据

20. Socket相关
- IP地址 + (TCP/UDP)协议 + 端口号 = Socket
- Socket是对TCP/IP协议的抽象，是操作系统对外开放的接口
- Socket起源于Unix，Unix遵从一切皆文件的哲学，Socket基于从打开到读写再到关闭的模式实现的，服务器和客户端各自维护
一个文件，在建立连接打开后，向自己的文件写入内容供对方读取，或者读取对方文件内容，在通信结束时就会关闭文件

- Socket通信流程：
              创建    绑定socket端口号   监听端口号    接收连接请求   从socket读取  关闭socket
Server ---> socket() ---> build() ---> listen() ---> accept() ---> recv() ---> close()

Client ---> socket()           --->          connect() ---> send()        ---> close()       
              创建                              连接         写入信息          关闭socket
              
21. java使用Socket
- TCP: ServerSocket
- UDP: DatagramSocket + DatagramPacket

22. CSRF(跨站点请求伪造)攻击与防御
- 我们正常登陆受信任网站A时，浏览器会保存session信息。在本次会话没有结束前浏览了由黑客准备好的B网站, B网站中会利用我们的session信息伪装成我们向A网站发送一些请求, 获取信息、发送邮件、购买物品等
- 尽量使用post; 加入验证码; 验证referer; Anti CSRF token;
- 从始至终都是我们在操作电脑，若B网站调用A网站返回了消息也只会返回到我们的浏览器中，并不能到黑客的手中; 所以验证码的方式可以证明是由我们本人在操作而不是机器行为或黑客行为

23. XSS(跨站脚本)攻击与防御