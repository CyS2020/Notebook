1. TCP简介
- 面向链接的、可靠的、基于字节流的传输层通信协议
- 将应用层的数据流分割成报文段并发送给目标节点的TCP层
- 数据包都有序号，对方收到则发送ACK确认，未收到则重传
- 使用奇偶校验和函数来检验数据在传输过程中是否有误

2. TCP三次握手
- IP地址 + (TCP/UDP)协议 + 端口号 = 网络中的一个进程，该种标识也称socket
- SYN = 1, seq = x  ---> 客户端进入SYN-SENT状态
- SYN = 1, ACK = 1, seq = y, ack = x + 1 ---> 服务端进入SYN-RECV状态
- ACK = 1, seq = x + 1, ack = y + 1  ---> 客户端进入ESTABLISHED状态
- 服务端接收后也进入ESTABLISHED状态

3. 为什么需要三次握手才能建立连接
- 为了初始化Sequence Number的初始值，通信双方需要互相通知对方并确认对方已经收到

4. 首次握手的隐患-SYN超时
- 服务端收到客户端的SYN，回复SYN-ACK的时候未收到ACK确认，服务端不断重试直至63秒超时
- SYN Flood防范措施：SYN队列满后，tcp_syncookies参数回发SYN Cookie，客户端会回发SYN cookie，从而直接建立连接

5. 建立连接，客户端出现故障怎么办--保活机制
- 想对方发送保活探测报文，如果未收到响应则继续发送
- 尝试次数达到保活探测数仍未收到响应则中断连接

6. TCP四次挥手
- 在socket编程中，客户端与服务端一方执行close来触发
- FIN = 1, seq = u ---> 进入FIN-WAIT-1状态
- ACK = 1, seq = v, ack = u + 1 ---> 进入CLOSED-WAIT状态
- 客户端接收到后进入FIN-WAIT-2 此时服务端数据传送还要持续一段时间
- FIN = 1, ACK = 1, seq = w, ack = u + 1 ---> 进入LAST-ACK
- ACK = 1, seq = u + 1, ack = w + 1 ---> TIME-WAIT
- 服务端接收后进入CLOSED状态，客户端等待2MSL后也进入CLOSED状态，MSL=30s
- 注释：seq是累加的是自己的序号，ack确认的是别人的序号

7. 为什么有TIME_WAIT状态
- 确保有足够的时间让对方收到ACK包
- 避免新旧连接混淆

8. 为什么需要四次挥手才能断开连接
- 因为全双工，发送方和接收方都需要FIN报文和ACK报文
- 发送方和接收方均需两次挥手，只不过有一方是被动的看起来是四次

9. 服务器出现大量CLOSE_WAIT状态原因
- 对方关闭socket连接，我方忙于读写，没有及时关闭连接
- 检查代码，特别是释放资源的代码
- 检查配置，特别是处理请求的线程配置

10. UDP简介
- 面向非连接
- 不维护连接状态，支持同时向多个客户端传输相同的消息
- 数据包报头只有8个字节，额外开销较小
- 吞吐量只受限于数据生成速率、传输速率以及机器性能
- 尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表
- 面向报文，不对应用程序提交的报文信息进行拆分或者合并

11. TCP和UDP的区别
- 都是传输层的传输协议TCP用于可靠的传输，UDP则用于让网络和细节控制交给应用层的通信传输
- 面向连接 vs 无连接，UDP适合消息的多播发布
- 可靠性 = 握手确认 + 重传机制
- 有序性 = 序列号 + 排序
- 速度 TCP < UDP
- TCP重量级，UDP轻量级

12. TCP的滑窗
- RTT: 发送一个数据包到收到对应的ACK，所花费的时间; RTO: 重传时间间隔
- TCP使用滑动窗口做流量控制与乱序重排
- 保证TCP的可靠性; 保证TCP的流控特性
- 报文中window字段用于接收方通知发送方自己还有多少缓冲区可以接收数据

- TCP缓存内数据分类
- TCP会话发送方：已确认 + (已发送 + 允许发送) + 不允许发送; 括号内为发送窗口
- TCP会话接收方：已确认 + (允许接收) + 不允许接收; 括号内为接收窗口
- 滑动窗口大小可以依据一定策略调整：接收端会根据自己处理能力的变化通过window大小设置，来实现限制发送方的流量

13. HTTP简介
- 支持客户/服务器模式，简单快速，灵活，无连接，无状态

14. 请求/响应步骤
- 浏览器连接到web服务器，与端口80建立一个tcp套接字连接
- 发送Http请求，浏览器通过套接字向服务器发送文本的请求报文
- 服务器接收请求并返回HTTP响应，web服务器解析请求定位请求资源，将资源副本写入套接字由客户端读取
- 释放TCP连接，服务端主动关闭连接，客户端被动关闭连接
- 浏览器解析HTML内容

15. 在浏览器地址栏键入URL，按下回车之后经历的流程
- DNS解析，根据URL逐层查询DNS缓存解析域名对应的IP地址，
由近及远：浏览器缓存 -> 系统缓存 -> 路由器缓存 -> IPS网路运营商缓存 -> 域名服务器缓存 -> 顶级域名服务器缓存
- TCP连接
- 发送HTTP请求
- 服务器处理请求并返回HTTP报文
- 浏览器解析渲染页面
- 连接结束释放TCP连接

16. HTTP状态码
- 1xx: 指示信息--表示请求已接收，继续处理
- 2xx: 成功--表示请求一杯成功接收、理解、接受
- 3xx: 重定向--要完成请求必须进行更进一步的操作
- 4xx: 客户端错误--请求有语法错误或请求无法实现
- 5xx: 服务端错误--服务端未能实现合法的请求

- 200 OK: 正常返回信息
- 400 Bad Request: 客户端请求有语法错误，不能被服务器理解
- 401 Unauthorized: 请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用
- 403 Forbidden: 服务器收到请求，但是拒绝提供服务
- 404 Not Found: 请求资源不存在，eg，输入了错误的URL
- 500 Internal Server Error: 服务器发生不可预测的错误
- 503 Server Unavailable: 服务器不能处理当前客户端的请求，一段时间后可能恢复正常
 
17. GET请求和POST请求的区别
- Http报文层面：GET请求信息放在URL后，请求信息为?后面的键值对，POST将请求信息放置在报文体中
- 数据库层面：GET符合幂等性和安全性，POST不符合
- 其他层面：GET可以被浏览器缓存、被存储，而POST不行

18. Cookie和Session的区别
- Cookie数据存放在客户端的浏览器上，Session数据放在服务器上
- Session相对于Cookie更安全
- 若考虑减轻服务器负担，应当使用Cookie

- Cookie: 客户端机制，由服务器发给客户端的特殊信息，以文本的形式存放在客户端
当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息，并且提交至服务器，
紧接着服务器在响应客户端请求发送超文本，也会发回这些处理后的个人信息即Cookie(存放在HTTP响应头中)，当客户端接收到服务端的响应之后，
浏览器会将这些信息存放在统一的位置，客户端再次请求的时候，会把Cookie发回服务器(存放在HTTP请求头中)，
服务器接收到后，回解析Cookie生成与客户端相对应的内容，用户不需要重复输入个人信息
- Cookie的设置及发送过程:
Client  ---         HTTP Request      ---> Server
Client <--- HTTP Response + Set-Cookie --- Server
Client  --- HTTP Request + Cookie     ---> Server
Client <---         HTTP Response      --- Server
           
- Session: 服务端机制，服务器使用了一种类似散列表的结构来保存信息
当服务器需要为某个客户端请求创建一个Session的时候，服务器检查请求中是否包含了Session标识即session id
则说明以前已经为此客户端创建了Session，服务器则通过session id检索出Session信息来使用，如果检索不到就新建一个Session
如果客户端请求不包含session id则为此客户端创建一个Session，并且生成一个相对应的session id，在本次响应中回发给客户端
- Session实现方式1: 使用Cookie来实现，服务器给每个Session分配一个将JSESSIONID存放在Cookie中发给客户端
客户端发起新的请求的时候将在Cookie头中携带JSESSIONID，服务器就能找到与客户端对应的Session
- Session实现方式2: 使用URL会回写来实现，服务器在发送给浏览器的所有页面中都携带JSESSIONID参数，这样浏览器点击任何链接
均会把JSESSIONID带回服务器，如果在浏览器输入服务端资源的URL请求该资源，那么Session是找不到的

19. HTTP与HTTPS的区别
- HTTPS: 超文本传输安全协议，在HTTP与TCP之间添加了一层SSL(安全套接字层)
- SSL: 为网络通信提供安全及数据完整性的一种安全协议，是操作系统对外的API，采用身份验证和数据加密保证网络和数据的完整性
- 加密方式：对称加密--加密和解密都是同一个密钥; 非对称加密--加密(公钥)和解密(私钥)使用的密钥是不相同的; 
哈希算法--任意长度信息转换为固定长度的值MD5算法; 数字签名--证明某个消息或者文件时某个人发出/认同的

- HTTPS数据传输流程
浏览器将支持的加密算法信息发送给服务器，服务器选择一套浏览器支持的加密算法，以证书的形式发送给浏览器，
证书里包含了证书发布的机构、证书的有效期、公钥、证书所有者、还有签名等