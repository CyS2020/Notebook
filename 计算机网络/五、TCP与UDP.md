## TCP 传输控制协议，UDP 用户数据报协议

### 1. 传输层的作用

-   IP首部中有一个协议字段，用来标识网络层（IP）的上一层是采用的是哪一种协议。根据这个字段的协议号，就可以识别IP传输的数据部分究竟是TCP的内容还是UDP的内容。传输层的TCP/UDP为了识别自己所传输的数据部分究竟该发给哪个应用也设定了一个编号 - **端口号**

    ![HTTP连接请求](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/HTTP%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82.jpg)

-   一些服务端程序在UNIX系统当中叫做守护进程。例如HTTP的服务端程序是httpd（HTTP守护进程），而ssh的服务端程序是sshd（SSH守护进程）。在UNIX中并不需要将这些守护进程逐个启动，而是启动一个可以代表他们接受客户端请求的inetd（互联网守护进程）服务程序即可，它是一种超级守护进程，收到客户端的请求以后会复刻（fork）新的进程并转换（exec）为sshd等各个守护进程
-   确认请求究竟是发给哪个服务端（守护进程），可以通过收到的目标端口号识别。当收到TCP的建立连接请求时，如果目标端口号为22则转给sshd，如果是80则转给httpd。

-   TCP是面向连接的可靠的流协议，TCP为提供**可靠性传输**、实行**顺序控制**和**重发控制**机制。此外还具有**流量控制**、**拥塞控制**、**提高网络利用率**等功能。UPD是不具有可靠性的数据报协议。UDP可以确保发送消息的大小，却不能保证消息一定会到达。
-   应用程序利用套接字，可以设置对端的IP地址、端口号、并实现数据的发送与接收

### 2. 端口号

-   数据链路和IP中的地址，分别指的是MAC地址和IP地址。前者用来识别同一链路中不同的计算机，后者用来识别TCP/IP网络中互连的主机和路由器，传输层中地址就是端口号，用来识别同一计算机中进行通信的不同应用程序，也被称为程序地址
-   标准既定的端口号：也叫静态分配法。每个应用程序都有其指定的端口号。例如HTTP、TELENT、FTP等广为使用的应用协议中所有使用的端口号就是固定的。也被称之为知名端口号。知名端口号一般由0--1023的数字分配而成。应用程序应该避免使用知名端口号进行既定目的之外的通信，以免发生冲突。还有一些端口号也被正式注册他们分布在1024--49151的数字之间。这些端口号可以用于任何通信用途。

-   时序分配法：也叫动态分配法。此时，服务端有必要确定监听端口号，但是接受服务的客户端没有必要确定看口号。这种方法下，客户端应用程序可以完全不用自己设置端口号，全权交给操作系统进行分配。操作系统可以为每个应用分配互不冲突的端口号。动态分配端口号取值范围在49152--65535

### 3. 端口号协议

-   端口号是由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。例如TCP与UDP使用同一个端口号，但使用目的各不相同。这是因为端口号上的处理是根据每个传输协议的不同进行的。数据达到IP层检查IP首部的协议号，传给相应的模块，若TCP则转TCP模块，若UDP则转UDP模块做端口号的处理。
-   那些知名的端口号与传输层协议并无关系，只要端口一致，都将分配同一种程序进行处理。例如53号端口在TCP与UDP中都用于DNS服务，而80端口用于HTTP通信。

### 4. UDP

-   UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。网络拥堵无法进行流量控制，出现丢包不负责重发，顺序乱掉没有纠错功能。将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。可以说UDP按照制作程序的那些程序员的指示行事。
-   主要应用：1. 包总量较少的通信（DNS、SNMP等）。2. 视频、音频等多媒体通信（即时通信）。3. 限定于LAN等特定网络中的应用通信。4. 广播通信（广播、多播）

### 5. TCP

-   是对传输、发送、通信进行控制的协议。与UDP区别相当大。充分地实现了数据传输时各种控制功能，可以进行丢包重发，乱序的分包顺序控制，只有在通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过**检验和、序列号、确认应答、重发控制、连接管理、窗口控制**等机制实现可靠传输

---

#### 序列号与确认应答

-   通过序列号与确认应答提高可靠性，TCP通过肯定的确认应答（ACK）实现可靠的数据传输。当发送端的数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端，反之，数据丢失可能性大

    ![正常的数据传输](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93.jpg)

-   数据包丢失的情况，在一定时间内没有等到确定应答，发送端就可以认为数据已经丢失，并进行重发。由此即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。

    ![数据包丢失的情况](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%83%85%E5%86%B5.jpg)

-   未收到确认应答并不意味着数据一定丢失。也有可能是对方已经收到，只是在返回确认应答的途中丢失。这种情况也会导致发送端因没有收到确认应答，而认为数据没有到达目的地，从而进行重新发送。

    ![确认应答丢失的情况](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%83%85%E5%86%B5.jpg)

-   此外还有可能因为其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源发送主机只要按照机制重发数据即可。但目标主机会反复收到相同数据，放弃重复的数据包。为此，就必须引入一种机制，识别是否已经接收数据，又能判断是否需要接收。

-   上述这些确认应答处理、重发控制、重复控制等功能都可以通过**序列号**实现。序列号是按顺序给发送数据的每个字节都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序号作为确认应答返送回去。通过序列号和确认应答号，TCP可以实现可靠传输。

    ![发送数据](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE.jpg)

---

#### 重发超时

-   再重发数据之前，等待确认应答到来的那个特定时间间隔该如何确定。TCP要求无论处于何种网络环境都要提供高性能的通信，并且无论网络拥堵情况发生何种变化都必须保持这一特性。为此，每次发包都回计算往返时间时间（RTT）及其偏差（RTT时间波动值、方差也称抖动）。重发超时时间就是比两者总和稍微大一点的值

    ![往返时间的计算](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4%E7%9A%84%E8%AE%A1%E7%AE%97.jpg)

-   Unix和window系统中，超时都是以0.5秒为单位进行控制的，因此重发超时都是0.5秒的整数倍。偏差的最小值也是0.5秒，因此最小的重发时间是1秒。初始值一般设置为6秒

-   数据被重发之后还是收不到确认应答，则再次进行发送。此时等待确认应答的时间将会以2倍、4倍的时间指数延长。重发一定次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端发生异常强制关闭

---

#### 连接管理

-   连接开始时通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答。如果对端发来确认应答则认为可以进行通信。在通信结束时会发送进行断开连接处理的FIN包

    ![TCP连接的建立与断开](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E6%96%AD%E5%BC%80.jpg)

-   建立TCP连接的同时，也可以确定发送数据包的单位，我们称之为最大消息长度（MSS）,最理想的情况是，最大消息长度正好是IP中不会被分片处理的最大数据长度，TCP在传送大量数据时，是以MSS的大小将数据进行分割发送。重发时也是以MSS为单位。

-   MSS在三次握手的时候，在两端主机之间被计算得出。两端主机在发出建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应MSS的大小，然后选择一个较小值投入使用。如果某一方的MSS被省略，可以选为IP包的长度不超过576字节的值（IP首部20字节，TCP首部20字节，MSS 536字节）

    ![以太网主机与FDDI主机通信](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E4%BB%A5%E5%A4%AA%E7%BD%91%E4%B8%BB%E6%9C%BA%E4%B8%8EFDDI%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1.jpg)

---

#### 滑动窗口

-   使用滑动窗口并行处理，确认应答不再是以每个分段，而是以更大的单位进行确认，转发时间会被大幅缩短，发送端主机发送一个段后不必要一直等待确认应答，而是继续发送。窗口的大小就是指无需等待确认应答而可以继续发送数据的最大值。图中大小为4。

    ![用滑动窗口方式并行处理](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E7%94%A8%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%96%B9%E5%BC%8F%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86.jpg)

-   该机制实现了大量的缓冲区，通过对多个段进行同时确认应答的功能，发送端确认应答到来则代表之前的数据包均有收到，发送端将数据从缓存区中清除。接收端如果某一段丢失，之后的段保存缓冲区然后等待该缺口被填上，如果一直填不上这缺口后面的段也会丢弃，如果填上了，直接对已经收到的报文进行一次确认。

-   在窗口比较大的时候，又出现报文丢失，同一个序号的确认应答将会被重复不断地返回，发送端主机如果连续**三次**（三次duplicated ACK 不一定是丢包造成的，但丢包肯定会造成三次duplicated ACK）收到同一个确认应答就将其所对应的数据进行重发。

    ![高速控制重发控制](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E9%AB%98%E9%80%9F%E9%87%8D%E5%8F%91%E6%8E%A7%E5%88%B6.jpg)

---

#### 流量控制

-   TCP的流量控制让发送端根据接收端的实际接收能力控制发送的数据量，接收端向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据，该限度就被称作窗口的大小。不过接收端缓冲区一旦面临数据溢出，窗口大小的值也会被设置为一个更小的值通知给发送端，从而控制数据量的发送。

    ![流量控制](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.jpg)

-   缓冲区即满，不得不暂停接收数据。发送端收到窗口更新通知后通信才能继续进行，窗口更新通知如果在传送途中丢失会导致无法继续通行，发送端要是不是的发送一个窗口探测数据段。仅含一个字节获取最新窗口大小

---

#### 拥塞控制

-   为了防止刚开始就发送较大的数据包造成网络拥堵，TCP通过一个叫慢启动的算法得出数值，对发送数据量进行控制，拥塞窗口设置为1，之后每次收到确认应答，拥塞窗口增加，同接收端主机发来的窗口大小相比较，发送的数据量小于两者的最小值。拥塞窗口不能无限制的增长，引入慢启动阈值的概念，按比例放大拥塞窗口

    ![慢启动](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E6%85%A2%E5%90%AF%E5%8A%A8.jpg)

-   TCP通信开始时不设置慢启动阈值，，而是在超时重发时，才会设置为当时拥塞窗口一半的大小。窗口的大小影响数据量被转发的吞吐量，窗口越大，越会形成高的吞吐量

    ![TCP的窗口变化](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/TCP%E7%AA%97%E5%8F%A3%E5%8F%98%E5%8C%96.jpg)

---

### 6. 其他传输层协议

-   UDP-Lite 轻量级用户数据报协议：扩展UPD机能的一种传输协议。计算检验和的范围可以由应用自行决定，针对那些不允许发生错误部分进行校验和检查，其他部分即使发生了错误，也可以忽略不计。
-   SCTP 流控制传输协议：与TCP一样都是提供数据到达与否可靠性检查的传输协议。1. 以消息为单位进行收发。2. 支持多重宿主。3. 支持多数据流通信。4. 可以定义消息生存期限
-   DCCP 数据报拥塞控制协议：一个辅助UDP的崭新的传输层协议。1. 不提供发送数据可靠性传输。2. 面向连接，在连接与断开上是具有可靠性的。3. 能够根据网络拥堵情况进行拥塞控制。4. 为了进行拥塞控制，接收端收到包以后返回确认应答。该确认应答将被用于重发与否的判断。

### 7. UDP首部格式

![UDP数据段格式](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/UDP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.jpg)

-   源端口号：字段长16位，表示发送端端口号，可选字段，有时不需要设置

-   目标端口号：字段长16位，表示接收端端口号

-   包长度：字段长16位，保存了UDP首部和数据的长度之和，单位为字节

-   校验和：字段长16位，提供可靠的UDP首部和数据而设计，可选字段，如果传输有误则丢弃。32位源IP地址，32位目标IP地址，8位填充0，8位协议号，16位TCP包长度

    ![UDP伪首部](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/UDP%E4%BC%AA%E9%A6%96%E9%83%A8.jpg)

    

### 8. TCP首部格式

![TCP数据段格式](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/TCP%E6%95%B0%E6%8D%AE%E6%AE%B5%E6%A0%BC%E5%BC%8F.jpg)

-   源端口号：字段长16位，表示发送端端口号

-   目标端口号：字段长16位，表示接收端端口号

-   序列号：字段长32位，指的是数据发送的位置，每发送一次数据，就累加一次该数据字节数大小

-   确认应答号：字段长32位，下一次应该收到的数据的序列号

-   数据偏移：字段长4位，TCP所传输的数据部分应该从TCP包的哪个为开始计算，单位4字节。如果没有可选字段的话，TCP首部为20字节，数据偏移设置为5。

-   保留：字段长4位，为了以后扩展使用

-   控制位：字段长8位，每一位从左至右分别为：CWR，ECE, URG, ACK, PSH, RST, SYN, FIN。

    ![控制位](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E6%8E%A7%E5%88%B6%E4%BD%8D.jpg)

    -   CWR：CWR标志与后面的ECE标识用于ECN字段。ECN设置为1时，通知对方已将拥塞窗口缩小
    -   ECE：表示ECN-Echo。置为1时通知对方这边有网络拥塞，从对方到接收有网络拥塞，数据包IP首部为1时将TCP首部ECE设为1
    -   URG：该位为1时，表示包中有紧急处理的数据
    -   ACK：该位为1时，确认应答有效。TCP规定除了最初建立连接的SYN包之外该位必须设置为1
    -   PSH：该位为1时，表示需要将收到的数据立刻传给上层应用协议，为0时则不需要立即传而是先进行缓存
    -   RST：该位为1时，表示TCP连接中出现异常必须强制断开连接
    -   SYN：该位为1时，表示希望建立连接，并在其序列号的字段进行序列号的初始值的设定
    -   FIN：该位为1时，表示今后不会再有数据发送，希望断开连接。
    
-   窗口大小：字段长16位，用于通知从TCP首部确认应答号所指位置开始能够接受的数据大小，单位字节，TCP不允许发送超过此处所示大小的数据，如果窗口为0，则表示可以发送窗口探测，以了解最新窗口大小

-   校验和：字段长16位。TCP的校验和与UDP相似，TCP的校验和无法关闭，32位源IP地址，32位目标IP地址，8位填充0，8位8位协议号，16位TCP包长度

    ![TCP伪首部](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/TCP%E4%BC%AA%E9%A6%96%E9%83%A8.jpg)

-   紧急指针：字段长16位，只有在URG控制位为1时有效。该字段的数值表示报文中紧急数据的指针。该字段的数值表示本报文中紧急数据的指针。从数据部分的首位到紧急指针所指示的位置为止是紧急数据。一般在暂时中断通信，或中断通信的情况下使用。
-   选项：提高TCP的传输性能，根据数据偏移（首部长度）进行控制，最大长度可根据TCP首部长度进行推算。TCP首部长度用4位表示，那么选项部分最长为：(2^4-1)*4-20=40字节。
-   填充：保证TCP首部为32位的整数倍