## .

## TCP 传输控制协议，UDP 用户数据报协议

### 1. 传输层的作用

-   IP首部中有一个协议字段，用来标识网络层（IP）的上一层是采用的是哪一种协议。根据这个字段的协议号，就可以识别IP传输的数据部分究竟是TCP的内容还是UDP的内容。传输层的TCP/UDP为了识别自己所传输的数据部分究竟该发给哪个应用也设定了一个编号 - **端口号**

    ![HTTP连接请求](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/HTTP%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82.jpg)

-   一些服务端程序在UNIX系统当中叫做守护进程。例如HTTP的服务端程序是httpd（HTTP守护进程），而ssh的服务端程序是sshd（SSH守护进程）。在UNIX中并不需要将这些守护进程逐个启动，而是启动一个可以代表他们接受客户端请求的inetd（互联网守护进程）服务程序即可，它是一种超级守护进程，收到客户端的请求以后会复刻（fork）新的进程并转换（exec）为sshd等各个守护进程
-   确认请求究竟是发给哪个服务端（守护进程），可以通过收到的目标端口号识别。当收到TCP的建立连接请求时，如果目标端口号为22则转给sshd，如果是80则转给httpd。

-   TCP是面向连接的可靠的流协议，TCP为提供**可靠性传输**、实行**顺序控制**和**重发控制**机制。此外还具有**流量控制**、**拥塞控制**、**提高网络利用率**等功能。UPD是不具有可靠性的数据报协议。UDP可以确保发送消息的大小，却不能保证消息一定会到达。
-   应用程序利用套接字，可以设置对端的IP地址、端口号、并实现数据的发送与接收

### 2. 端口号

-   数据链路和IP中的地址，分别指的是MAC地址和IP地址。前者用来识别同一链路中不同的计算机，后者用来识别TCP/IP网络中互连的主机和路由器，传输层中地址就是端口号，用来识别同一计算机中进行通信的不同应用程序，也被称为程序地址
-   标准既定的端口号：也叫静态分配法。每个应用程序都有其指定的端口号。例如HTTP、TELENT、FTP等广为使用的应用协议中所有使用的端口号就是固定的。也被称之为知名端口号。知名端口号一般由0~1023的数字分配而成。应用程序应该避免使用知名端口号进行既定目的之外的通信，以免发生冲突。还有一些端口号也被正式注册他们分布在1024~49151的数字之间。这些端口号可以用于任何通信用途。

-   时序分配法：也叫动态分配法。此时，服务端有必要确定监听端口号，但是接受服务的客户端没有必要确定看口号。这种方法下，客户端应用程序可以完全不用自己设置端口号，全权交给操作系统进行分配。操作系统可以为每个应用分配互不冲突的端口号。动态分配端口号取值范围在49152~65535

### 3. 端口号协议

-   端口号是由其使用的传输层协议决定。因此，不同的传输层协议可以使用相同的端口号。例如TCP与UDP使用同一个端口号，但使用目的各不相同。这是因为端口号上的处理是根据每个传输协议的不同进行的。数据达到IP层检查IP首部的协议号，传给相应的模块，若TCP则转TCP模块，若UDP则转UDP模块做端口号的处理。
-   那些知名的端口号与传输层协议并无关系，只要端口一致，都将分配同一种程序进行处理。例如53号端口在TCP与UDP中都用于DNS服务，而80端口用于HTTP通信。

### 4. UDP

-   UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。网络拥堵无法进行流量控制，出现丢包不负责重发，顺序乱掉没有纠错功能。将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。可以说UDP按照制作程序的那些程序员的指示行事。
-   主要应用：1. 包总量较少的通信（DNS、SNMP等）。2. 视频、音频等多媒体通信（即时通信）。3. 限定于LAN等特定网络中的应用通信。4. 广播通信（广播、多播）

### 5. TCP

-   是对传输、发送、通信进行控制的协议。与UDP区别相当大。充分地实现了数据传输时各种控制功能，可以进行丢包重发，乱序的分包顺序控制，只有在通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过**检验和、序列号、确认应答、重发控制、连接管理、窗口控制**等机制实现可靠传输

---

-     通过序列号与确认应答提高可靠性，TCP通过肯定的确认应答（ACK）实现可靠的数据传输。当发送端的数据发出之后会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端，反之，数据丢失可能性大

    ![正常的数据传输](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93.jpg)

-   数据包丢失的情况，在一定时间内没有等到确定应答，发送端就可以认为数据已经丢失，并进行重发。由此即使产生了丢包，仍然能够保证数据能够到达对端，实现可靠传输。

    ![数据包丢失的情况](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%83%85%E5%86%B5.jpg)

-   未收到确认应答并不意味着数据一定丢失。也有可能是对方已经收到，只是在返回确认应答的途中丢失。这种情况也会导致发送端因没有收到确认应答，而认为数据没有到达目的地，从而进行重新发送。

    ![确认应答丢失的情况](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%83%85%E5%86%B5.jpg)

-   此外还有可能因为其他原因导致确认应答延迟到达，在源主机重发数据以后才到达的情况也屡见不鲜。此时，源发送主机只要按照机制重发数据即可。但目标主机会反复收到相同数据，放弃重复的数据包。为此，就必须引入一种机制，识别是否已经接收数据，又能判断是否需要接收。

-   上述这些确认应答处理、重发控制、重复控制等功能都可以通过**序列号**实现。序列号是按顺序给发送数据的每个字节都标上号码的编号。接收端查询接收数据TCP首部中的序列号和数据的长度，将自己下一步应该接收的序号作为确认应答返送回去。通过序列号和确认应答号，TCP可以实现可靠传输。

    ![发送数据](https://github.com/CyS2020/Notebook/raw/master/%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87/%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE.jpg)

---

-   再重发数据之前，等待确认应答到来的那个特定时间间隔该如何确定。TCP要求无论处于何种网络环境都要提供高性能的通信，并且无论网络拥堵情况发生何种变化都必须保持这一特性。为此，每次发包都回计算往返时间时间（RTT）及其偏差（RTT时间波动值、方差也称抖动）。重发超时时间就是比两者总和稍微大一点的值

    ![往返时间的计算]()

-   Unix和window系统中，超时都是以0.5秒为单位进行控制的，因此重发超时都是0.5秒的整数倍。偏差的最小值也是0.5秒，因此最小的重发时间是1秒。初始值一般设置为6秒

-   数据被重发之后还是收不到确认应答，则再次进行发送。此时等待确认应答的时间将会以2倍、4倍的时间指数延长。重发一定次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端发生异常强制关闭

---

-   连接开始时通过TCP首部发送一个SYN包作为建立连接的请求等待确认应答。如果对端发来确认应答则认为可以进行通信。在通信结束时会发送进行断开连接处理的FIN包

    ![TCP连接的建立与断开]()

-   建立TCP连接的同时，也可以确定发送数据包的单位，我们称之为最大消息长度（MSS）,最理想的情况是，最大消息长度正好是IP中不会被分片处理的最大数据长度，TCP在传送大量数据时，是以MSS的大小将数据进行分割发送。重发时也是以MSS为单位。

-   MSS在三次握手的时候，在两端主机之间被计算得出。两端主机在发出建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方自己的接口能够适应MSS的大小，然后选择一个较小值投入使用。如果某一方的MSS被省略，可以选为IP包的长度不超过576字节的值（IP首部20字节，TCP首部20字节，MSS 536字节）

    ![以太网主机与FDDI主机通信]()

---

